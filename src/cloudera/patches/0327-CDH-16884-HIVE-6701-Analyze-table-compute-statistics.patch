From 0a065b48fbdf039676bfa538055844faca584a30 Mon Sep 17 00:00:00 2001
From: Sergey Shelukhin <sershe@apache.org>
Date: Thu, 27 Mar 2014 23:40:03 +0000
Subject: [PATCH 327/375] CDH:16884: HIVE-6701 Analyze table compute statistics for decimal columns. (Sergey Shelukhin and Jitendra Nath Pandey, reviewed by Ashutosh Chauhan)

git-svn-id: https://svn.apache.org/repos/asf/hive/trunk@1582546 13f79535-47bb-0310-9956-ffa450edef68

Conflicts:
	metastore/src/gen/thrift/gen-cpp/hive_metastore_types.cpp
	metastore/src/gen/thrift/gen-cpp/hive_metastore_types.h
	metastore/src/gen/thrift/gen-php/metastore/Types.php
	metastore/src/gen/thrift/gen-py/hive_metastore/ttypes.py
	metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
	metastore/src/java/org/apache/hadoop/hive/metastore/StatObjectConverter.java
---
 data/files/decimal.txt                             |   18 +
 metastore/if/hive_metastore.thrift                 |   16 +-
 .../gen/thrift/gen-cpp/hive_metastore_types.cpp    |  217 ++++++-
 .../src/gen/thrift/gen-cpp/hive_metastore_types.h  |  124 ++++-
 .../hive/metastore/api/ColumnStatisticsData.java   |   63 ++-
 .../apache/hadoop/hive/metastore/api/Decimal.java  |  494 ++++++++++++++
 .../hive/metastore/api/DecimalColumnStatsData.java |  690 ++++++++++++++++++++
 .../src/gen/thrift/gen-php/metastore/Types.php     |  259 ++++++++
 .../src/gen/thrift/gen-py/hive_metastore/ttypes.py |  198 ++++++-
 .../src/gen/thrift/gen-rb/hive_metastore_types.rb  |   54 ++-
 .../hadoop/hive/metastore/MetaStoreDirectSql.java  |  139 ++++-
 .../hadoop/hive/metastore/StatObjectConverter.java |  369 +++++++++++
 .../model/MPartitionColumnStatistics.java          |   26 +
 .../metastore/model/MTableColumnStatistics.java    |   27 +
 metastore/src/model/package.jdo                    |   12 +
 .../hadoop/hive/ql/exec/ColumnStatsTask.java       |   34 +
 .../generic/DecimalNumDistinctValueEstimator.java  |   42 ++
 .../ql/udf/generic/GenericUDAFComputeStats.java    |  315 +++++++++-
 .../apache/hadoop/hive/ql/util/JavaDataModel.java  |  107 +++-
 .../queries/clientpositive/compute_stats_decimal.q |   11 +
 .../clientpositive/compute_stats_decimal.q.out     |   33 +
 .../hadoop/hive/serde/test/ThriftTestObj.java      |    4 +-
 .../hadoop/hive/serde2/thrift/test/Complex.java    |   12 +-
 .../hadoop/hive/serde2/thrift/test/MegaStruct.java |   32 +-
 .../org/apache/hadoop/hive/service/ThriftHive.java |    8 +-
 25 files changed, 3250 insertions(+), 54 deletions(-)
 create mode 100644 data/files/decimal.txt
 create mode 100644 metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/Decimal.java
 create mode 100644 metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/DecimalColumnStatsData.java
 mode change 100644 => 100755 metastore/src/gen/thrift/gen-py/hive_metastore/ThriftHiveMetastore-remote
 create mode 100644 metastore/src/java/org/apache/hadoop/hive/metastore/StatObjectConverter.java
 create mode 100644 ql/src/java/org/apache/hadoop/hive/ql/udf/generic/DecimalNumDistinctValueEstimator.java
 create mode 100644 ql/src/test/queries/clientpositive/compute_stats_decimal.q
 create mode 100644 ql/src/test/results/clientpositive/compute_stats_decimal.q.out

diff --git a/src/data/files/decimal.txt b/src/data/files/decimal.txt
new file mode 100644
index 0000000..28800f5
--- /dev/null
+++ b/src/data/files/decimal.txt
@@ -0,0 +1,18 @@
+55.33
+44.2
+435.33
+324.33
+324.33
+44.2
+55.3
+55.3
+0.0
+
+66.4
+23.22
+-87.2
+
+33.44
+55.3
+435.331
+-0.342
\ No newline at end of file
diff --git a/src/metastore/if/hive_metastore.thrift b/src/metastore/if/hive_metastore.thrift
index 43b3907..ff61e2f 100755
--- a/src/metastore/if/hive_metastore.thrift
+++ b/src/metastore/if/hive_metastore.thrift
@@ -229,12 +229,26 @@ struct BinaryColumnStatsData {
 3: required i64 numNulls
 }
 
+
+struct Decimal {
+1: required binary unscaled,
+3: required i16 scale
+}
+
+struct DecimalColumnStatsData {
+1: required Decimal lowValue,
+2: required Decimal highValue,
+3: required i64 numNulls,
+4: required i64 numDVs
+}
+
 union ColumnStatisticsData {
 1: BooleanColumnStatsData booleanStats,
 2: LongColumnStatsData longStats,
 3: DoubleColumnStatsData doubleStats,
 4: StringColumnStatsData stringStats,
-5: BinaryColumnStatsData binaryStats
+5: BinaryColumnStatsData binaryStats,
+6: DecimalColumnStatsData decimalStats
 }
 
 struct ColumnStatisticsObj {
diff --git a/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.cpp b/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.cpp
index 62ecaa0..7c2f5fb 100644
--- a/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.cpp
+++ b/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.cpp
@@ -3079,8 +3079,200 @@ void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b) {
   swap(a.numNulls, b.numNulls);
 }
 
-const char* ColumnStatisticsData::ascii_fingerprint = "3D106F26C0761EF37E58CAFAA3F1651C";
-const uint8_t ColumnStatisticsData::binary_fingerprint[16] = {0x3D,0x10,0x6F,0x26,0xC0,0x76,0x1E,0xF3,0x7E,0x58,0xCA,0xFA,0xA3,0xF1,0x65,0x1C};
+const char* Decimal::ascii_fingerprint = "C4DDF6759F9B17C5C380806CE743DE8E";
+const uint8_t Decimal::binary_fingerprint[16] = {0xC4,0xDD,0xF6,0x75,0x9F,0x9B,0x17,0xC5,0xC3,0x80,0x80,0x6C,0xE7,0x43,0xDE,0x8E};
+
+uint32_t Decimal::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+  bool isset_unscaled = false;
+  bool isset_scale = false;
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 1:
+        if (ftype == ::apache::thrift::protocol::T_STRING) {
+          xfer += iprot->readBinary(this->unscaled);
+          isset_unscaled = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      case 3:
+        if (ftype == ::apache::thrift::protocol::T_I16) {
+          xfer += iprot->readI16(this->scale);
+          isset_scale = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  if (!isset_unscaled)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  if (!isset_scale)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  return xfer;
+}
+
+uint32_t Decimal::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("Decimal");
+
+  xfer += oprot->writeFieldBegin("unscaled", ::apache::thrift::protocol::T_STRING, 1);
+  xfer += oprot->writeBinary(this->unscaled);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I16, 3);
+  xfer += oprot->writeI16(this->scale);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+void swap(Decimal &a, Decimal &b) {
+  using ::std::swap;
+  swap(a.unscaled, b.unscaled);
+  swap(a.scale, b.scale);
+}
+
+const char* DecimalColumnStatsData::ascii_fingerprint = "3AE5C36598A014EE815B87600C3087B5";
+const uint8_t DecimalColumnStatsData::binary_fingerprint[16] = {0x3A,0xE5,0xC3,0x65,0x98,0xA0,0x14,0xEE,0x81,0x5B,0x87,0x60,0x0C,0x30,0x87,0xB5};
+
+uint32_t DecimalColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+  bool isset_lowValue = false;
+  bool isset_highValue = false;
+  bool isset_numNulls = false;
+  bool isset_numDVs = false;
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 1:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->lowValue.read(iprot);
+          isset_lowValue = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      case 2:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->highValue.read(iprot);
+          isset_highValue = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      case 3:
+        if (ftype == ::apache::thrift::protocol::T_I64) {
+          xfer += iprot->readI64(this->numNulls);
+          isset_numNulls = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      case 4:
+        if (ftype == ::apache::thrift::protocol::T_I64) {
+          xfer += iprot->readI64(this->numDVs);
+          isset_numDVs = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  if (!isset_lowValue)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  if (!isset_highValue)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  if (!isset_numNulls)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  if (!isset_numDVs)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  return xfer;
+}
+
+uint32_t DecimalColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("DecimalColumnStatsData");
+
+  xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
+  xfer += this->lowValue.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
+  xfer += this->highValue.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
+  xfer += oprot->writeI64(this->numNulls);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
+  xfer += oprot->writeI64(this->numDVs);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b) {
+  using ::std::swap;
+  swap(a.lowValue, b.lowValue);
+  swap(a.highValue, b.highValue);
+  swap(a.numNulls, b.numNulls);
+  swap(a.numDVs, b.numDVs);
+}
+
+const char* ColumnStatisticsData::ascii_fingerprint = "343F5865568AF7DA61829A616EB8C57C";
+const uint8_t ColumnStatisticsData::binary_fingerprint[16] = {0x34,0x3F,0x58,0x65,0x56,0x8A,0xF7,0xDA,0x61,0x82,0x9A,0x61,0x6E,0xB8,0xC5,0x7C};
 
 uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot) {
 
@@ -3142,6 +3334,14 @@ uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot
           xfer += iprot->skip(ftype);
         }
         break;
+      case 6:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->decimalStats.read(iprot);
+          this->__isset.decimalStats = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
       default:
         xfer += iprot->skip(ftype);
         break;
@@ -3178,6 +3378,10 @@ uint32_t ColumnStatisticsData::write(::apache::thrift::protocol::TProtocol* opro
   xfer += this->binaryStats.write(oprot);
   xfer += oprot->writeFieldEnd();
 
+  xfer += oprot->writeFieldBegin("decimalStats", ::apache::thrift::protocol::T_STRUCT, 6);
+  xfer += this->decimalStats.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
   xfer += oprot->writeFieldStop();
   xfer += oprot->writeStructEnd();
   return xfer;
@@ -3190,11 +3394,12 @@ void swap(ColumnStatisticsData &a, ColumnStatisticsData &b) {
   swap(a.doubleStats, b.doubleStats);
   swap(a.stringStats, b.stringStats);
   swap(a.binaryStats, b.binaryStats);
+  swap(a.decimalStats, b.decimalStats);
   swap(a.__isset, b.__isset);
 }
 
-const char* ColumnStatisticsObj::ascii_fingerprint = "DEE09584C51BCAF60824FE4509B59567";
-const uint8_t ColumnStatisticsObj::binary_fingerprint[16] = {0xDE,0xE0,0x95,0x84,0xC5,0x1B,0xCA,0xF6,0x08,0x24,0xFE,0x45,0x09,0xB5,0x95,0x67};
+const char* ColumnStatisticsObj::ascii_fingerprint = "CFDBB9DFF4F1670367EA5356861EC180";
+const uint8_t ColumnStatisticsObj::binary_fingerprint[16] = {0xCF,0xDB,0xB9,0xDF,0xF4,0xF1,0x67,0x03,0x67,0xEA,0x53,0x56,0x86,0x1E,0xC1,0x80};
 
 uint32_t ColumnStatisticsObj::read(::apache::thrift::protocol::TProtocol* iprot) {
 
@@ -3414,8 +3619,8 @@ void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b) {
   swap(a.__isset, b.__isset);
 }
 
-const char* ColumnStatistics::ascii_fingerprint = "681BDBD0CBB53373AC1C9C0C2E26BEAB";
-const uint8_t ColumnStatistics::binary_fingerprint[16] = {0x68,0x1B,0xDB,0xD0,0xCB,0xB5,0x33,0x73,0xAC,0x1C,0x9C,0x0C,0x2E,0x26,0xBE,0xAB};
+const char* ColumnStatistics::ascii_fingerprint = "37AA2F226C29DF25254CCCE6A7DDBAF3";
+const uint8_t ColumnStatistics::binary_fingerprint[16] = {0x37,0xAA,0x2F,0x22,0x6C,0x29,0xDF,0x25,0x25,0x4C,0xCC,0xE6,0xA7,0xDD,0xBA,0xF3};
 
 uint32_t ColumnStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {
 
diff --git a/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.h b/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.h
index abc4d65..fe347c6 100644
--- a/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.h
+++ b/src/metastore/src/gen/thrift/gen-cpp/hive_metastore_types.h
@@ -1630,20 +1630,123 @@ class BinaryColumnStatsData {
 
 void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b);
 
+
+class Decimal {
+ public:
+
+  static const char* ascii_fingerprint; // = "C4DDF6759F9B17C5C380806CE743DE8E";
+  static const uint8_t binary_fingerprint[16]; // = {0xC4,0xDD,0xF6,0x75,0x9F,0x9B,0x17,0xC5,0xC3,0x80,0x80,0x6C,0xE7,0x43,0xDE,0x8E};
+
+  Decimal() : unscaled(), scale(0) {
+  }
+
+  virtual ~Decimal() throw() {}
+
+  std::string unscaled;
+  int16_t scale;
+
+  void __set_unscaled(const std::string& val) {
+    unscaled = val;
+  }
+
+  void __set_scale(const int16_t val) {
+    scale = val;
+  }
+
+  bool operator == (const Decimal & rhs) const
+  {
+    if (!(unscaled == rhs.unscaled))
+      return false;
+    if (!(scale == rhs.scale))
+      return false;
+    return true;
+  }
+  bool operator != (const Decimal &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const Decimal & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+void swap(Decimal &a, Decimal &b);
+
+
+class DecimalColumnStatsData {
+ public:
+
+  static const char* ascii_fingerprint; // = "3AE5C36598A014EE815B87600C3087B5";
+  static const uint8_t binary_fingerprint[16]; // = {0x3A,0xE5,0xC3,0x65,0x98,0xA0,0x14,0xEE,0x81,0x5B,0x87,0x60,0x0C,0x30,0x87,0xB5};
+
+  DecimalColumnStatsData() : numNulls(0), numDVs(0) {
+  }
+
+  virtual ~DecimalColumnStatsData() throw() {}
+
+  Decimal lowValue;
+  Decimal highValue;
+  int64_t numNulls;
+  int64_t numDVs;
+
+  void __set_lowValue(const Decimal& val) {
+    lowValue = val;
+  }
+
+  void __set_highValue(const Decimal& val) {
+    highValue = val;
+  }
+
+  void __set_numNulls(const int64_t val) {
+    numNulls = val;
+  }
+
+  void __set_numDVs(const int64_t val) {
+    numDVs = val;
+  }
+
+  bool operator == (const DecimalColumnStatsData & rhs) const
+  {
+    if (!(lowValue == rhs.lowValue))
+      return false;
+    if (!(highValue == rhs.highValue))
+      return false;
+    if (!(numNulls == rhs.numNulls))
+      return false;
+    if (!(numDVs == rhs.numDVs))
+      return false;
+    return true;
+  }
+  bool operator != (const DecimalColumnStatsData &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const DecimalColumnStatsData & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b);
+
 typedef struct _ColumnStatisticsData__isset {
-  _ColumnStatisticsData__isset() : booleanStats(false), longStats(false), doubleStats(false), stringStats(false), binaryStats(false) {}
+  _ColumnStatisticsData__isset() : booleanStats(false), longStats(false), doubleStats(false), stringStats(false), binaryStats(false), decimalStats(false) {}
   bool booleanStats;
   bool longStats;
   bool doubleStats;
   bool stringStats;
   bool binaryStats;
+  bool decimalStats;
 } _ColumnStatisticsData__isset;
 
 class ColumnStatisticsData {
  public:
 
-  static const char* ascii_fingerprint; // = "3D106F26C0761EF37E58CAFAA3F1651C";
-  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x10,0x6F,0x26,0xC0,0x76,0x1E,0xF3,0x7E,0x58,0xCA,0xFA,0xA3,0xF1,0x65,0x1C};
+  static const char* ascii_fingerprint; // = "343F5865568AF7DA61829A616EB8C57C";
+  static const uint8_t binary_fingerprint[16]; // = {0x34,0x3F,0x58,0x65,0x56,0x8A,0xF7,0xDA,0x61,0x82,0x9A,0x61,0x6E,0xB8,0xC5,0x7C};
 
   ColumnStatisticsData() {
   }
@@ -1655,6 +1758,7 @@ class ColumnStatisticsData {
   DoubleColumnStatsData doubleStats;
   StringColumnStatsData stringStats;
   BinaryColumnStatsData binaryStats;
+  DecimalColumnStatsData decimalStats;
 
   _ColumnStatisticsData__isset __isset;
 
@@ -1678,6 +1782,10 @@ class ColumnStatisticsData {
     binaryStats = val;
   }
 
+  void __set_decimalStats(const DecimalColumnStatsData& val) {
+    decimalStats = val;
+  }
+
   bool operator == (const ColumnStatisticsData & rhs) const
   {
     if (!(booleanStats == rhs.booleanStats))
@@ -1690,6 +1798,8 @@ class ColumnStatisticsData {
       return false;
     if (!(binaryStats == rhs.binaryStats))
       return false;
+    if (!(decimalStats == rhs.decimalStats))
+      return false;
     return true;
   }
   bool operator != (const ColumnStatisticsData &rhs) const {
@@ -1709,8 +1819,8 @@ void swap(ColumnStatisticsData &a, ColumnStatisticsData &b);
 class ColumnStatisticsObj {
  public:
 
-  static const char* ascii_fingerprint; // = "DEE09584C51BCAF60824FE4509B59567";
-  static const uint8_t binary_fingerprint[16]; // = {0xDE,0xE0,0x95,0x84,0xC5,0x1B,0xCA,0xF6,0x08,0x24,0xFE,0x45,0x09,0xB5,0x95,0x67};
+  static const char* ascii_fingerprint; // = "CFDBB9DFF4F1670367EA5356861EC180";
+  static const uint8_t binary_fingerprint[16]; // = {0xCF,0xDB,0xB9,0xDF,0xF4,0xF1,0x67,0x03,0x67,0xEA,0x53,0x56,0x86,0x1E,0xC1,0x80};
 
   ColumnStatisticsObj() : colName(), colType() {
   }
@@ -1838,8 +1948,8 @@ void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b);
 class ColumnStatistics {
  public:
 
-  static const char* ascii_fingerprint; // = "681BDBD0CBB53373AC1C9C0C2E26BEAB";
-  static const uint8_t binary_fingerprint[16]; // = {0x68,0x1B,0xDB,0xD0,0xCB,0xB5,0x33,0x73,0xAC,0x1C,0x9C,0x0C,0x2E,0x26,0xBE,0xAB};
+  static const char* ascii_fingerprint; // = "37AA2F226C29DF25254CCCE6A7DDBAF3";
+  static const uint8_t binary_fingerprint[16]; // = {0x37,0xAA,0x2F,0x22,0x6C,0x29,0xDF,0x25,0x25,0x4C,0xCC,0xE6,0xA7,0xDD,0xBA,0xF3};
 
   ColumnStatistics() {
   }
diff --git a/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ColumnStatisticsData.java b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ColumnStatisticsData.java
index 848188a..c941e13 100644
--- a/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ColumnStatisticsData.java
+++ b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/ColumnStatisticsData.java
@@ -38,6 +38,7 @@
   private static final org.apache.thrift.protocol.TField DOUBLE_STATS_FIELD_DESC = new org.apache.thrift.protocol.TField("doubleStats", org.apache.thrift.protocol.TType.STRUCT, (short)3);
   private static final org.apache.thrift.protocol.TField STRING_STATS_FIELD_DESC = new org.apache.thrift.protocol.TField("stringStats", org.apache.thrift.protocol.TType.STRUCT, (short)4);
   private static final org.apache.thrift.protocol.TField BINARY_STATS_FIELD_DESC = new org.apache.thrift.protocol.TField("binaryStats", org.apache.thrift.protocol.TType.STRUCT, (short)5);
+  private static final org.apache.thrift.protocol.TField DECIMAL_STATS_FIELD_DESC = new org.apache.thrift.protocol.TField("decimalStats", org.apache.thrift.protocol.TType.STRUCT, (short)6);
 
   /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
   public enum _Fields implements org.apache.thrift.TFieldIdEnum {
@@ -45,7 +46,8 @@
     LONG_STATS((short)2, "longStats"),
     DOUBLE_STATS((short)3, "doubleStats"),
     STRING_STATS((short)4, "stringStats"),
-    BINARY_STATS((short)5, "binaryStats");
+    BINARY_STATS((short)5, "binaryStats"),
+    DECIMAL_STATS((short)6, "decimalStats");
 
     private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
@@ -70,6 +72,8 @@ public static _Fields findByThriftId(int fieldId) {
           return STRING_STATS;
         case 5: // BINARY_STATS
           return BINARY_STATS;
+        case 6: // DECIMAL_STATS
+          return DECIMAL_STATS;
         default:
           return null;
       }
@@ -122,6 +126,8 @@ public String getFieldName() {
         new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, StringColumnStatsData.class)));
     tmpMap.put(_Fields.BINARY_STATS, new org.apache.thrift.meta_data.FieldMetaData("binaryStats", org.apache.thrift.TFieldRequirementType.DEFAULT, 
         new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, BinaryColumnStatsData.class)));
+    tmpMap.put(_Fields.DECIMAL_STATS, new org.apache.thrift.meta_data.FieldMetaData("decimalStats", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+        new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, DecimalColumnStatsData.class)));
     metaDataMap = Collections.unmodifiableMap(tmpMap);
     org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ColumnStatisticsData.class, metaDataMap);
   }
@@ -171,6 +177,12 @@ public static ColumnStatisticsData binaryStats(BinaryColumnStatsData value) {
     return x;
   }
 
+  public static ColumnStatisticsData decimalStats(DecimalColumnStatsData value) {
+    ColumnStatisticsData x = new ColumnStatisticsData();
+    x.setDecimalStats(value);
+    return x;
+  }
+
 
   @Override
   protected void checkType(_Fields setField, Object value) throws ClassCastException {
@@ -200,6 +212,11 @@ protected void checkType(_Fields setField, Object value) throws ClassCastExcepti
           break;
         }
         throw new ClassCastException("Was expecting value of type BinaryColumnStatsData for field 'binaryStats', but got " + value.getClass().getSimpleName());
+      case DECIMAL_STATS:
+        if (value instanceof DecimalColumnStatsData) {
+          break;
+        }
+        throw new ClassCastException("Was expecting value of type DecimalColumnStatsData for field 'decimalStats', but got " + value.getClass().getSimpleName());
       default:
         throw new IllegalArgumentException("Unknown field id " + setField);
     }
@@ -260,6 +277,16 @@ protected Object standardSchemeReadValue(org.apache.thrift.protocol.TProtocol ip
             org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
             return null;
           }
+        case DECIMAL_STATS:
+          if (field.type == DECIMAL_STATS_FIELD_DESC.type) {
+            DecimalColumnStatsData decimalStats;
+            decimalStats = new DecimalColumnStatsData();
+            decimalStats.read(iprot);
+            return decimalStats;
+          } else {
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
+            return null;
+          }
         default:
           throw new IllegalStateException("setField wasn't null, but didn't match any of the case statements!");
       }
@@ -291,6 +318,10 @@ protected void standardSchemeWriteValue(org.apache.thrift.protocol.TProtocol opr
         BinaryColumnStatsData binaryStats = (BinaryColumnStatsData)value_;
         binaryStats.write(oprot);
         return;
+      case DECIMAL_STATS:
+        DecimalColumnStatsData decimalStats = (DecimalColumnStatsData)value_;
+        decimalStats.write(oprot);
+        return;
       default:
         throw new IllegalStateException("Cannot write union with unknown field " + setField_);
     }
@@ -326,6 +357,11 @@ protected Object tupleSchemeReadValue(org.apache.thrift.protocol.TProtocol iprot
           binaryStats = new BinaryColumnStatsData();
           binaryStats.read(iprot);
           return binaryStats;
+        case DECIMAL_STATS:
+          DecimalColumnStatsData decimalStats;
+          decimalStats = new DecimalColumnStatsData();
+          decimalStats.read(iprot);
+          return decimalStats;
         default:
           throw new IllegalStateException("setField wasn't null, but didn't match any of the case statements!");
       }
@@ -357,6 +393,10 @@ protected void tupleSchemeWriteValue(org.apache.thrift.protocol.TProtocol oprot)
         BinaryColumnStatsData binaryStats = (BinaryColumnStatsData)value_;
         binaryStats.write(oprot);
         return;
+      case DECIMAL_STATS:
+        DecimalColumnStatsData decimalStats = (DecimalColumnStatsData)value_;
+        decimalStats.write(oprot);
+        return;
       default:
         throw new IllegalStateException("Cannot write union with unknown field " + setField_);
     }
@@ -375,6 +415,8 @@ protected void tupleSchemeWriteValue(org.apache.thrift.protocol.TProtocol oprot)
         return STRING_STATS_FIELD_DESC;
       case BINARY_STATS:
         return BINARY_STATS_FIELD_DESC;
+      case DECIMAL_STATS:
+        return DECIMAL_STATS_FIELD_DESC;
       default:
         throw new IllegalArgumentException("Unknown field id " + setField);
     }
@@ -465,6 +507,20 @@ public void setBinaryStats(BinaryColumnStatsData value) {
     value_ = value;
   }
 
+  public DecimalColumnStatsData getDecimalStats() {
+    if (getSetField() == _Fields.DECIMAL_STATS) {
+      return (DecimalColumnStatsData)getFieldValue();
+    } else {
+      throw new RuntimeException("Cannot get field 'decimalStats' because union is currently set to " + getFieldDesc(getSetField()).name);
+    }
+  }
+
+  public void setDecimalStats(DecimalColumnStatsData value) {
+    if (value == null) throw new NullPointerException();
+    setField_ = _Fields.DECIMAL_STATS;
+    value_ = value;
+  }
+
   public boolean isSetBooleanStats() {
     return setField_ == _Fields.BOOLEAN_STATS;
   }
@@ -490,6 +546,11 @@ public boolean isSetBinaryStats() {
   }
 
 
+  public boolean isSetDecimalStats() {
+    return setField_ == _Fields.DECIMAL_STATS;
+  }
+
+
   public boolean equals(Object other) {
     if (other instanceof ColumnStatisticsData) {
       return equals((ColumnStatisticsData)other);
diff --git a/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/Decimal.java b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/Decimal.java
new file mode 100644
index 0000000..ed8bb18
--- /dev/null
+++ b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/Decimal.java
@@ -0,0 +1,494 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.0)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hadoop.hive.metastore.api;
+
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.thrift.scheme.IScheme;
+import org.apache.thrift.scheme.SchemeFactory;
+import org.apache.thrift.scheme.StandardScheme;
+
+import org.apache.thrift.scheme.TupleScheme;
+import org.apache.thrift.protocol.TTupleProtocol;
+import org.apache.thrift.protocol.TProtocolException;
+import org.apache.thrift.EncodingUtils;
+import org.apache.thrift.TException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Decimal implements org.apache.thrift.TBase<Decimal, Decimal._Fields>, java.io.Serializable, Cloneable {
+  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("Decimal");
+
+  private static final org.apache.thrift.protocol.TField UNSCALED_FIELD_DESC = new org.apache.thrift.protocol.TField("unscaled", org.apache.thrift.protocol.TType.STRING, (short)1);
+  private static final org.apache.thrift.protocol.TField SCALE_FIELD_DESC = new org.apache.thrift.protocol.TField("scale", org.apache.thrift.protocol.TType.I16, (short)3);
+
+  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+  static {
+    schemes.put(StandardScheme.class, new DecimalStandardSchemeFactory());
+    schemes.put(TupleScheme.class, new DecimalTupleSchemeFactory());
+  }
+
+  private ByteBuffer unscaled; // required
+  private short scale; // required
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+    UNSCALED((short)1, "unscaled"),
+    SCALE((short)3, "scale");
+
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      switch(fieldId) {
+        case 1: // UNSCALED
+          return UNSCALED;
+        case 3: // SCALE
+          return SCALE;
+        default:
+          return null;
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  private static final int __SCALE_ISSET_ID = 0;
+  private byte __isset_bitfield = 0;
+  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+  static {
+    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+    tmpMap.put(_Fields.UNSCALED, new org.apache.thrift.meta_data.FieldMetaData("unscaled", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING        , true)));
+    tmpMap.put(_Fields.SCALE, new org.apache.thrift.meta_data.FieldMetaData("scale", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I16)));
+    metaDataMap = Collections.unmodifiableMap(tmpMap);
+    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Decimal.class, metaDataMap);
+  }
+
+  public Decimal() {
+  }
+
+  public Decimal(
+    ByteBuffer unscaled,
+    short scale)
+  {
+    this();
+    this.unscaled = unscaled;
+    this.scale = scale;
+    setScaleIsSet(true);
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public Decimal(Decimal other) {
+    __isset_bitfield = other.__isset_bitfield;
+    if (other.isSetUnscaled()) {
+      this.unscaled = org.apache.thrift.TBaseHelper.copyBinary(other.unscaled);
+;
+    }
+    this.scale = other.scale;
+  }
+
+  public Decimal deepCopy() {
+    return new Decimal(this);
+  }
+
+  @Override
+  public void clear() {
+    this.unscaled = null;
+    setScaleIsSet(false);
+    this.scale = 0;
+  }
+
+  public byte[] getUnscaled() {
+    setUnscaled(org.apache.thrift.TBaseHelper.rightSize(unscaled));
+    return unscaled == null ? null : unscaled.array();
+  }
+
+  public ByteBuffer bufferForUnscaled() {
+    return unscaled;
+  }
+
+  public void setUnscaled(byte[] unscaled) {
+    setUnscaled(unscaled == null ? (ByteBuffer)null : ByteBuffer.wrap(unscaled));
+  }
+
+  public void setUnscaled(ByteBuffer unscaled) {
+    this.unscaled = unscaled;
+  }
+
+  public void unsetUnscaled() {
+    this.unscaled = null;
+  }
+
+  /** Returns true if field unscaled is set (has been assigned a value) and false otherwise */
+  public boolean isSetUnscaled() {
+    return this.unscaled != null;
+  }
+
+  public void setUnscaledIsSet(boolean value) {
+    if (!value) {
+      this.unscaled = null;
+    }
+  }
+
+  public short getScale() {
+    return this.scale;
+  }
+
+  public void setScale(short scale) {
+    this.scale = scale;
+    setScaleIsSet(true);
+  }
+
+  public void unsetScale() {
+    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SCALE_ISSET_ID);
+  }
+
+  /** Returns true if field scale is set (has been assigned a value) and false otherwise */
+  public boolean isSetScale() {
+    return EncodingUtils.testBit(__isset_bitfield, __SCALE_ISSET_ID);
+  }
+
+  public void setScaleIsSet(boolean value) {
+    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SCALE_ISSET_ID, value);
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case UNSCALED:
+      if (value == null) {
+        unsetUnscaled();
+      } else {
+        setUnscaled((ByteBuffer)value);
+      }
+      break;
+
+    case SCALE:
+      if (value == null) {
+        unsetScale();
+      } else {
+        setScale((Short)value);
+      }
+      break;
+
+    }
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case UNSCALED:
+      return getUnscaled();
+
+    case SCALE:
+      return Short.valueOf(getScale());
+
+    }
+    throw new IllegalStateException();
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    if (field == null) {
+      throw new IllegalArgumentException();
+    }
+
+    switch (field) {
+    case UNSCALED:
+      return isSetUnscaled();
+    case SCALE:
+      return isSetScale();
+    }
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof Decimal)
+      return this.equals((Decimal)that);
+    return false;
+  }
+
+  public boolean equals(Decimal that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_unscaled = true && this.isSetUnscaled();
+    boolean that_present_unscaled = true && that.isSetUnscaled();
+    if (this_present_unscaled || that_present_unscaled) {
+      if (!(this_present_unscaled && that_present_unscaled))
+        return false;
+      if (!this.unscaled.equals(that.unscaled))
+        return false;
+    }
+
+    boolean this_present_scale = true;
+    boolean that_present_scale = true;
+    if (this_present_scale || that_present_scale) {
+      if (!(this_present_scale && that_present_scale))
+        return false;
+      if (this.scale != that.scale)
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    HashCodeBuilder builder = new HashCodeBuilder();
+
+    boolean present_unscaled = true && (isSetUnscaled());
+    builder.append(present_unscaled);
+    if (present_unscaled)
+      builder.append(unscaled);
+
+    boolean present_scale = true;
+    builder.append(present_scale);
+    if (present_scale)
+      builder.append(scale);
+
+    return builder.toHashCode();
+  }
+
+  public int compareTo(Decimal other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    Decimal typedOther = (Decimal)other;
+
+    lastComparison = Boolean.valueOf(isSetUnscaled()).compareTo(typedOther.isSetUnscaled());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetUnscaled()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.unscaled, typedOther.unscaled);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetScale()).compareTo(typedOther.isSetScale());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetScale()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.scale, typedOther.scale);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public _Fields fieldForId(int fieldId) {
+    return _Fields.findByThriftId(fieldId);
+  }
+
+  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+  }
+
+  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("Decimal(");
+    boolean first = true;
+
+    sb.append("unscaled:");
+    if (this.unscaled == null) {
+      sb.append("null");
+    } else {
+      org.apache.thrift.TBaseHelper.toString(this.unscaled, sb);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("scale:");
+    sb.append(this.scale);
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws org.apache.thrift.TException {
+    // check for required fields
+    if (!isSetUnscaled()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'unscaled' is unset! Struct:" + toString());
+    }
+
+    if (!isSetScale()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'scale' is unset! Struct:" + toString());
+    }
+
+    // check for sub-struct validity
+  }
+
+  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+    try {
+      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+    try {
+      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
+      __isset_bitfield = 0;
+      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private static class DecimalStandardSchemeFactory implements SchemeFactory {
+    public DecimalStandardScheme getScheme() {
+      return new DecimalStandardScheme();
+    }
+  }
+
+  private static class DecimalStandardScheme extends StandardScheme<Decimal> {
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot, Decimal struct) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField schemeField;
+      iprot.readStructBegin();
+      while (true)
+      {
+        schemeField = iprot.readFieldBegin();
+        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (schemeField.id) {
+          case 1: // UNSCALED
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+              struct.unscaled = iprot.readBinary();
+              struct.setUnscaledIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 3: // SCALE
+            if (schemeField.type == org.apache.thrift.protocol.TType.I16) {
+              struct.scale = iprot.readI16();
+              struct.setScaleIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+      struct.validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot, Decimal struct) throws org.apache.thrift.TException {
+      struct.validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (struct.unscaled != null) {
+        oprot.writeFieldBegin(UNSCALED_FIELD_DESC);
+        oprot.writeBinary(struct.unscaled);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(SCALE_FIELD_DESC);
+      oprot.writeI16(struct.scale);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+  }
+
+  private static class DecimalTupleSchemeFactory implements SchemeFactory {
+    public DecimalTupleScheme getScheme() {
+      return new DecimalTupleScheme();
+    }
+  }
+
+  private static class DecimalTupleScheme extends TupleScheme<Decimal> {
+
+    @Override
+    public void write(org.apache.thrift.protocol.TProtocol prot, Decimal struct) throws org.apache.thrift.TException {
+      TTupleProtocol oprot = (TTupleProtocol) prot;
+      oprot.writeBinary(struct.unscaled);
+      oprot.writeI16(struct.scale);
+    }
+
+    @Override
+    public void read(org.apache.thrift.protocol.TProtocol prot, Decimal struct) throws org.apache.thrift.TException {
+      TTupleProtocol iprot = (TTupleProtocol) prot;
+      struct.unscaled = iprot.readBinary();
+      struct.setUnscaledIsSet(true);
+      struct.scale = iprot.readI16();
+      struct.setScaleIsSet(true);
+    }
+  }
+
+}
+
diff --git a/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/DecimalColumnStatsData.java b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/DecimalColumnStatsData.java
new file mode 100644
index 0000000..5661252
--- /dev/null
+++ b/src/metastore/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/metastore/api/DecimalColumnStatsData.java
@@ -0,0 +1,690 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.0)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hadoop.hive.metastore.api;
+
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.thrift.scheme.IScheme;
+import org.apache.thrift.scheme.SchemeFactory;
+import org.apache.thrift.scheme.StandardScheme;
+
+import org.apache.thrift.scheme.TupleScheme;
+import org.apache.thrift.protocol.TTupleProtocol;
+import org.apache.thrift.protocol.TProtocolException;
+import org.apache.thrift.EncodingUtils;
+import org.apache.thrift.TException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DecimalColumnStatsData implements org.apache.thrift.TBase<DecimalColumnStatsData, DecimalColumnStatsData._Fields>, java.io.Serializable, Cloneable {
+  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("DecimalColumnStatsData");
+
+  private static final org.apache.thrift.protocol.TField LOW_VALUE_FIELD_DESC = new org.apache.thrift.protocol.TField("lowValue", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+  private static final org.apache.thrift.protocol.TField HIGH_VALUE_FIELD_DESC = new org.apache.thrift.protocol.TField("highValue", org.apache.thrift.protocol.TType.STRUCT, (short)2);
+  private static final org.apache.thrift.protocol.TField NUM_NULLS_FIELD_DESC = new org.apache.thrift.protocol.TField("numNulls", org.apache.thrift.protocol.TType.I64, (short)3);
+  private static final org.apache.thrift.protocol.TField NUM_DVS_FIELD_DESC = new org.apache.thrift.protocol.TField("numDVs", org.apache.thrift.protocol.TType.I64, (short)4);
+
+  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+  static {
+    schemes.put(StandardScheme.class, new DecimalColumnStatsDataStandardSchemeFactory());
+    schemes.put(TupleScheme.class, new DecimalColumnStatsDataTupleSchemeFactory());
+  }
+
+  private Decimal lowValue; // required
+  private Decimal highValue; // required
+  private long numNulls; // required
+  private long numDVs; // required
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+    LOW_VALUE((short)1, "lowValue"),
+    HIGH_VALUE((short)2, "highValue"),
+    NUM_NULLS((short)3, "numNulls"),
+    NUM_DVS((short)4, "numDVs");
+
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      switch(fieldId) {
+        case 1: // LOW_VALUE
+          return LOW_VALUE;
+        case 2: // HIGH_VALUE
+          return HIGH_VALUE;
+        case 3: // NUM_NULLS
+          return NUM_NULLS;
+        case 4: // NUM_DVS
+          return NUM_DVS;
+        default:
+          return null;
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  private static final int __NUMNULLS_ISSET_ID = 0;
+  private static final int __NUMDVS_ISSET_ID = 1;
+  private byte __isset_bitfield = 0;
+  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+  static {
+    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+    tmpMap.put(_Fields.LOW_VALUE, new org.apache.thrift.meta_data.FieldMetaData("lowValue", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, Decimal.class)));
+    tmpMap.put(_Fields.HIGH_VALUE, new org.apache.thrift.meta_data.FieldMetaData("highValue", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, Decimal.class)));
+    tmpMap.put(_Fields.NUM_NULLS, new org.apache.thrift.meta_data.FieldMetaData("numNulls", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
+    tmpMap.put(_Fields.NUM_DVS, new org.apache.thrift.meta_data.FieldMetaData("numDVs", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
+    metaDataMap = Collections.unmodifiableMap(tmpMap);
+    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(DecimalColumnStatsData.class, metaDataMap);
+  }
+
+  public DecimalColumnStatsData() {
+  }
+
+  public DecimalColumnStatsData(
+    Decimal lowValue,
+    Decimal highValue,
+    long numNulls,
+    long numDVs)
+  {
+    this();
+    this.lowValue = lowValue;
+    this.highValue = highValue;
+    this.numNulls = numNulls;
+    setNumNullsIsSet(true);
+    this.numDVs = numDVs;
+    setNumDVsIsSet(true);
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public DecimalColumnStatsData(DecimalColumnStatsData other) {
+    __isset_bitfield = other.__isset_bitfield;
+    if (other.isSetLowValue()) {
+      this.lowValue = new Decimal(other.lowValue);
+    }
+    if (other.isSetHighValue()) {
+      this.highValue = new Decimal(other.highValue);
+    }
+    this.numNulls = other.numNulls;
+    this.numDVs = other.numDVs;
+  }
+
+  public DecimalColumnStatsData deepCopy() {
+    return new DecimalColumnStatsData(this);
+  }
+
+  @Override
+  public void clear() {
+    this.lowValue = null;
+    this.highValue = null;
+    setNumNullsIsSet(false);
+    this.numNulls = 0;
+    setNumDVsIsSet(false);
+    this.numDVs = 0;
+  }
+
+  public Decimal getLowValue() {
+    return this.lowValue;
+  }
+
+  public void setLowValue(Decimal lowValue) {
+    this.lowValue = lowValue;
+  }
+
+  public void unsetLowValue() {
+    this.lowValue = null;
+  }
+
+  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */
+  public boolean isSetLowValue() {
+    return this.lowValue != null;
+  }
+
+  public void setLowValueIsSet(boolean value) {
+    if (!value) {
+      this.lowValue = null;
+    }
+  }
+
+  public Decimal getHighValue() {
+    return this.highValue;
+  }
+
+  public void setHighValue(Decimal highValue) {
+    this.highValue = highValue;
+  }
+
+  public void unsetHighValue() {
+    this.highValue = null;
+  }
+
+  /** Returns true if field highValue is set (has been assigned a value) and false otherwise */
+  public boolean isSetHighValue() {
+    return this.highValue != null;
+  }
+
+  public void setHighValueIsSet(boolean value) {
+    if (!value) {
+      this.highValue = null;
+    }
+  }
+
+  public long getNumNulls() {
+    return this.numNulls;
+  }
+
+  public void setNumNulls(long numNulls) {
+    this.numNulls = numNulls;
+    setNumNullsIsSet(true);
+  }
+
+  public void unsetNumNulls() {
+    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);
+  }
+
+  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */
+  public boolean isSetNumNulls() {
+    return EncodingUtils.testBit(__isset_bitfield, __NUMNULLS_ISSET_ID);
+  }
+
+  public void setNumNullsIsSet(boolean value) {
+    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUMNULLS_ISSET_ID, value);
+  }
+
+  public long getNumDVs() {
+    return this.numDVs;
+  }
+
+  public void setNumDVs(long numDVs) {
+    this.numDVs = numDVs;
+    setNumDVsIsSet(true);
+  }
+
+  public void unsetNumDVs() {
+    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUMDVS_ISSET_ID);
+  }
+
+  /** Returns true if field numDVs is set (has been assigned a value) and false otherwise */
+  public boolean isSetNumDVs() {
+    return EncodingUtils.testBit(__isset_bitfield, __NUMDVS_ISSET_ID);
+  }
+
+  public void setNumDVsIsSet(boolean value) {
+    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUMDVS_ISSET_ID, value);
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case LOW_VALUE:
+      if (value == null) {
+        unsetLowValue();
+      } else {
+        setLowValue((Decimal)value);
+      }
+      break;
+
+    case HIGH_VALUE:
+      if (value == null) {
+        unsetHighValue();
+      } else {
+        setHighValue((Decimal)value);
+      }
+      break;
+
+    case NUM_NULLS:
+      if (value == null) {
+        unsetNumNulls();
+      } else {
+        setNumNulls((Long)value);
+      }
+      break;
+
+    case NUM_DVS:
+      if (value == null) {
+        unsetNumDVs();
+      } else {
+        setNumDVs((Long)value);
+      }
+      break;
+
+    }
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case LOW_VALUE:
+      return getLowValue();
+
+    case HIGH_VALUE:
+      return getHighValue();
+
+    case NUM_NULLS:
+      return Long.valueOf(getNumNulls());
+
+    case NUM_DVS:
+      return Long.valueOf(getNumDVs());
+
+    }
+    throw new IllegalStateException();
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    if (field == null) {
+      throw new IllegalArgumentException();
+    }
+
+    switch (field) {
+    case LOW_VALUE:
+      return isSetLowValue();
+    case HIGH_VALUE:
+      return isSetHighValue();
+    case NUM_NULLS:
+      return isSetNumNulls();
+    case NUM_DVS:
+      return isSetNumDVs();
+    }
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof DecimalColumnStatsData)
+      return this.equals((DecimalColumnStatsData)that);
+    return false;
+  }
+
+  public boolean equals(DecimalColumnStatsData that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_lowValue = true && this.isSetLowValue();
+    boolean that_present_lowValue = true && that.isSetLowValue();
+    if (this_present_lowValue || that_present_lowValue) {
+      if (!(this_present_lowValue && that_present_lowValue))
+        return false;
+      if (!this.lowValue.equals(that.lowValue))
+        return false;
+    }
+
+    boolean this_present_highValue = true && this.isSetHighValue();
+    boolean that_present_highValue = true && that.isSetHighValue();
+    if (this_present_highValue || that_present_highValue) {
+      if (!(this_present_highValue && that_present_highValue))
+        return false;
+      if (!this.highValue.equals(that.highValue))
+        return false;
+    }
+
+    boolean this_present_numNulls = true;
+    boolean that_present_numNulls = true;
+    if (this_present_numNulls || that_present_numNulls) {
+      if (!(this_present_numNulls && that_present_numNulls))
+        return false;
+      if (this.numNulls != that.numNulls)
+        return false;
+    }
+
+    boolean this_present_numDVs = true;
+    boolean that_present_numDVs = true;
+    if (this_present_numDVs || that_present_numDVs) {
+      if (!(this_present_numDVs && that_present_numDVs))
+        return false;
+      if (this.numDVs != that.numDVs)
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    HashCodeBuilder builder = new HashCodeBuilder();
+
+    boolean present_lowValue = true && (isSetLowValue());
+    builder.append(present_lowValue);
+    if (present_lowValue)
+      builder.append(lowValue);
+
+    boolean present_highValue = true && (isSetHighValue());
+    builder.append(present_highValue);
+    if (present_highValue)
+      builder.append(highValue);
+
+    boolean present_numNulls = true;
+    builder.append(present_numNulls);
+    if (present_numNulls)
+      builder.append(numNulls);
+
+    boolean present_numDVs = true;
+    builder.append(present_numDVs);
+    if (present_numDVs)
+      builder.append(numDVs);
+
+    return builder.toHashCode();
+  }
+
+  public int compareTo(DecimalColumnStatsData other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    DecimalColumnStatsData typedOther = (DecimalColumnStatsData)other;
+
+    lastComparison = Boolean.valueOf(isSetLowValue()).compareTo(typedOther.isSetLowValue());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetLowValue()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lowValue, typedOther.lowValue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetHighValue()).compareTo(typedOther.isSetHighValue());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetHighValue()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.highValue, typedOther.highValue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetNumNulls()).compareTo(typedOther.isSetNumNulls());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetNumNulls()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.numNulls, typedOther.numNulls);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetNumDVs()).compareTo(typedOther.isSetNumDVs());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetNumDVs()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.numDVs, typedOther.numDVs);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public _Fields fieldForId(int fieldId) {
+    return _Fields.findByThriftId(fieldId);
+  }
+
+  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+  }
+
+  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("DecimalColumnStatsData(");
+    boolean first = true;
+
+    sb.append("lowValue:");
+    if (this.lowValue == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.lowValue);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("highValue:");
+    if (this.highValue == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.highValue);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("numNulls:");
+    sb.append(this.numNulls);
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("numDVs:");
+    sb.append(this.numDVs);
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws org.apache.thrift.TException {
+    // check for required fields
+    if (!isSetLowValue()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'lowValue' is unset! Struct:" + toString());
+    }
+
+    if (!isSetHighValue()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'highValue' is unset! Struct:" + toString());
+    }
+
+    if (!isSetNumNulls()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'numNulls' is unset! Struct:" + toString());
+    }
+
+    if (!isSetNumDVs()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'numDVs' is unset! Struct:" + toString());
+    }
+
+    // check for sub-struct validity
+    if (lowValue != null) {
+      lowValue.validate();
+    }
+    if (highValue != null) {
+      highValue.validate();
+    }
+  }
+
+  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+    try {
+      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+    try {
+      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
+      __isset_bitfield = 0;
+      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private static class DecimalColumnStatsDataStandardSchemeFactory implements SchemeFactory {
+    public DecimalColumnStatsDataStandardScheme getScheme() {
+      return new DecimalColumnStatsDataStandardScheme();
+    }
+  }
+
+  private static class DecimalColumnStatsDataStandardScheme extends StandardScheme<DecimalColumnStatsData> {
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot, DecimalColumnStatsData struct) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField schemeField;
+      iprot.readStructBegin();
+      while (true)
+      {
+        schemeField = iprot.readFieldBegin();
+        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (schemeField.id) {
+          case 1: // LOW_VALUE
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+              struct.lowValue = new Decimal();
+              struct.lowValue.read(iprot);
+              struct.setLowValueIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 2: // HIGH_VALUE
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+              struct.highValue = new Decimal();
+              struct.highValue.read(iprot);
+              struct.setHighValueIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 3: // NUM_NULLS
+            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
+              struct.numNulls = iprot.readI64();
+              struct.setNumNullsIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 4: // NUM_DVS
+            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
+              struct.numDVs = iprot.readI64();
+              struct.setNumDVsIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+      struct.validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot, DecimalColumnStatsData struct) throws org.apache.thrift.TException {
+      struct.validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (struct.lowValue != null) {
+        oprot.writeFieldBegin(LOW_VALUE_FIELD_DESC);
+        struct.lowValue.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (struct.highValue != null) {
+        oprot.writeFieldBegin(HIGH_VALUE_FIELD_DESC);
+        struct.highValue.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(NUM_NULLS_FIELD_DESC);
+      oprot.writeI64(struct.numNulls);
+      oprot.writeFieldEnd();
+      oprot.writeFieldBegin(NUM_DVS_FIELD_DESC);
+      oprot.writeI64(struct.numDVs);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+  }
+
+  private static class DecimalColumnStatsDataTupleSchemeFactory implements SchemeFactory {
+    public DecimalColumnStatsDataTupleScheme getScheme() {
+      return new DecimalColumnStatsDataTupleScheme();
+    }
+  }
+
+  private static class DecimalColumnStatsDataTupleScheme extends TupleScheme<DecimalColumnStatsData> {
+
+    @Override
+    public void write(org.apache.thrift.protocol.TProtocol prot, DecimalColumnStatsData struct) throws org.apache.thrift.TException {
+      TTupleProtocol oprot = (TTupleProtocol) prot;
+      struct.lowValue.write(oprot);
+      struct.highValue.write(oprot);
+      oprot.writeI64(struct.numNulls);
+      oprot.writeI64(struct.numDVs);
+    }
+
+    @Override
+    public void read(org.apache.thrift.protocol.TProtocol prot, DecimalColumnStatsData struct) throws org.apache.thrift.TException {
+      TTupleProtocol iprot = (TTupleProtocol) prot;
+      struct.lowValue = new Decimal();
+      struct.lowValue.read(iprot);
+      struct.setLowValueIsSet(true);
+      struct.highValue = new Decimal();
+      struct.highValue.read(iprot);
+      struct.setHighValueIsSet(true);
+      struct.numNulls = iprot.readI64();
+      struct.setNumNullsIsSet(true);
+      struct.numDVs = iprot.readI64();
+      struct.setNumDVsIsSet(true);
+    }
+  }
+
+}
+
diff --git a/src/metastore/src/gen/thrift/gen-php/metastore/Types.php b/src/metastore/src/gen/thrift/gen-php/metastore/Types.php
index 4c93bea..a062542 100644
--- a/src/metastore/src/gen/thrift/gen-php/metastore/Types.php
+++ b/src/metastore/src/gen/thrift/gen-php/metastore/Types.php
@@ -4054,6 +4054,240 @@ class BinaryColumnStatsData {
 
 }
 
+class Decimal {
+  static $_TSPEC;
+
+  public $unscaled = null;
+  public $scale = null;
+
+  public function __construct($vals=null) {
+    if (!isset(self::$_TSPEC)) {
+      self::$_TSPEC = array(
+        1 => array(
+          'var' => 'unscaled',
+          'type' => TType::STRING,
+          ),
+        3 => array(
+          'var' => 'scale',
+          'type' => TType::I16,
+          ),
+        );
+    }
+    if (is_array($vals)) {
+      if (isset($vals['unscaled'])) {
+        $this->unscaled = $vals['unscaled'];
+      }
+      if (isset($vals['scale'])) {
+        $this->scale = $vals['scale'];
+      }
+    }
+  }
+
+  public function getName() {
+    return 'Decimal';
+  }
+
+  public function read($input)
+  {
+    $xfer = 0;
+    $fname = null;
+    $ftype = 0;
+    $fid = 0;
+    $xfer += $input->readStructBegin($fname);
+    while (true)
+    {
+      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
+      if ($ftype == TType::STOP) {
+        break;
+      }
+      switch ($fid)
+      {
+        case 1:
+          if ($ftype == TType::STRING) {
+            $xfer += $input->readString($this->unscaled);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        case 3:
+          if ($ftype == TType::I16) {
+            $xfer += $input->readI16($this->scale);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        default:
+          $xfer += $input->skip($ftype);
+          break;
+      }
+      $xfer += $input->readFieldEnd();
+    }
+    $xfer += $input->readStructEnd();
+    return $xfer;
+  }
+
+  public function write($output) {
+    $xfer = 0;
+    $xfer += $output->writeStructBegin('Decimal');
+    if ($this->unscaled !== null) {
+      $xfer += $output->writeFieldBegin('unscaled', TType::STRING, 1);
+      $xfer += $output->writeString($this->unscaled);
+      $xfer += $output->writeFieldEnd();
+    }
+    if ($this->scale !== null) {
+      $xfer += $output->writeFieldBegin('scale', TType::I16, 3);
+      $xfer += $output->writeI16($this->scale);
+      $xfer += $output->writeFieldEnd();
+    }
+    $xfer += $output->writeFieldStop();
+    $xfer += $output->writeStructEnd();
+    return $xfer;
+  }
+
+}
+
+class DecimalColumnStatsData {
+  static $_TSPEC;
+
+  public $lowValue = null;
+  public $highValue = null;
+  public $numNulls = null;
+  public $numDVs = null;
+
+  public function __construct($vals=null) {
+    if (!isset(self::$_TSPEC)) {
+      self::$_TSPEC = array(
+        1 => array(
+          'var' => 'lowValue',
+          'type' => TType::STRUCT,
+          'class' => '\metastore\Decimal',
+          ),
+        2 => array(
+          'var' => 'highValue',
+          'type' => TType::STRUCT,
+          'class' => '\metastore\Decimal',
+          ),
+        3 => array(
+          'var' => 'numNulls',
+          'type' => TType::I64,
+          ),
+        4 => array(
+          'var' => 'numDVs',
+          'type' => TType::I64,
+          ),
+        );
+    }
+    if (is_array($vals)) {
+      if (isset($vals['lowValue'])) {
+        $this->lowValue = $vals['lowValue'];
+      }
+      if (isset($vals['highValue'])) {
+        $this->highValue = $vals['highValue'];
+      }
+      if (isset($vals['numNulls'])) {
+        $this->numNulls = $vals['numNulls'];
+      }
+      if (isset($vals['numDVs'])) {
+        $this->numDVs = $vals['numDVs'];
+      }
+    }
+  }
+
+  public function getName() {
+    return 'DecimalColumnStatsData';
+  }
+
+  public function read($input)
+  {
+    $xfer = 0;
+    $fname = null;
+    $ftype = 0;
+    $fid = 0;
+    $xfer += $input->readStructBegin($fname);
+    while (true)
+    {
+      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
+      if ($ftype == TType::STOP) {
+        break;
+      }
+      switch ($fid)
+      {
+        case 1:
+          if ($ftype == TType::STRUCT) {
+            $this->lowValue = new \metastore\Decimal();
+            $xfer += $this->lowValue->read($input);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        case 2:
+          if ($ftype == TType::STRUCT) {
+            $this->highValue = new \metastore\Decimal();
+            $xfer += $this->highValue->read($input);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        case 3:
+          if ($ftype == TType::I64) {
+            $xfer += $input->readI64($this->numNulls);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        case 4:
+          if ($ftype == TType::I64) {
+            $xfer += $input->readI64($this->numDVs);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        default:
+          $xfer += $input->skip($ftype);
+          break;
+      }
+      $xfer += $input->readFieldEnd();
+    }
+    $xfer += $input->readStructEnd();
+    return $xfer;
+  }
+
+  public function write($output) {
+    $xfer = 0;
+    $xfer += $output->writeStructBegin('DecimalColumnStatsData');
+    if ($this->lowValue !== null) {
+      if (!is_object($this->lowValue)) {
+        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
+      }
+      $xfer += $output->writeFieldBegin('lowValue', TType::STRUCT, 1);
+      $xfer += $this->lowValue->write($output);
+      $xfer += $output->writeFieldEnd();
+    }
+    if ($this->highValue !== null) {
+      if (!is_object($this->highValue)) {
+        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
+      }
+      $xfer += $output->writeFieldBegin('highValue', TType::STRUCT, 2);
+      $xfer += $this->highValue->write($output);
+      $xfer += $output->writeFieldEnd();
+    }
+    if ($this->numNulls !== null) {
+      $xfer += $output->writeFieldBegin('numNulls', TType::I64, 3);
+      $xfer += $output->writeI64($this->numNulls);
+      $xfer += $output->writeFieldEnd();
+    }
+    if ($this->numDVs !== null) {
+      $xfer += $output->writeFieldBegin('numDVs', TType::I64, 4);
+      $xfer += $output->writeI64($this->numDVs);
+      $xfer += $output->writeFieldEnd();
+    }
+    $xfer += $output->writeFieldStop();
+    $xfer += $output->writeStructEnd();
+    return $xfer;
+  }
+
+}
+
 class ColumnStatisticsData {
   static $_TSPEC;
 
@@ -4062,6 +4296,7 @@ class ColumnStatisticsData {
   public $doubleStats = null;
   public $stringStats = null;
   public $binaryStats = null;
+  public $decimalStats = null;
 
   public function __construct($vals=null) {
     if (!isset(self::$_TSPEC)) {
@@ -4091,6 +4326,11 @@ class ColumnStatisticsData {
           'type' => TType::STRUCT,
           'class' => '\metastore\BinaryColumnStatsData',
           ),
+        6 => array(
+          'var' => 'decimalStats',
+          'type' => TType::STRUCT,
+          'class' => '\metastore\DecimalColumnStatsData',
+          ),
         );
     }
     if (is_array($vals)) {
@@ -4109,6 +4349,9 @@ class ColumnStatisticsData {
       if (isset($vals['binaryStats'])) {
         $this->binaryStats = $vals['binaryStats'];
       }
+      if (isset($vals['decimalStats'])) {
+        $this->decimalStats = $vals['decimalStats'];
+      }
     }
   }
 
@@ -4171,6 +4414,14 @@ class ColumnStatisticsData {
             $xfer += $input->skip($ftype);
           }
           break;
+        case 6:
+          if ($ftype == TType::STRUCT) {
+            $this->decimalStats = new \metastore\DecimalColumnStatsData();
+            $xfer += $this->decimalStats->read($input);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
         default:
           $xfer += $input->skip($ftype);
           break;
@@ -4224,6 +4475,14 @@ class ColumnStatisticsData {
       $xfer += $this->binaryStats->write($output);
       $xfer += $output->writeFieldEnd();
     }
+    if ($this->decimalStats !== null) {
+      if (!is_object($this->decimalStats)) {
+        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
+      }
+      $xfer += $output->writeFieldBegin('decimalStats', TType::STRUCT, 6);
+      $xfer += $this->decimalStats->write($output);
+      $xfer += $output->writeFieldEnd();
+    }
     $xfer += $output->writeFieldStop();
     $xfer += $output->writeStructEnd();
     return $xfer;
diff --git a/src/metastore/src/gen/thrift/gen-py/hive_metastore/ThriftHiveMetastore-remote b/src/metastore/src/gen/thrift/gen-py/hive_metastore/ThriftHiveMetastore-remote
old mode 100644
new mode 100755
diff --git a/src/metastore/src/gen/thrift/gen-py/hive_metastore/ttypes.py b/src/metastore/src/gen/thrift/gen-py/hive_metastore/ttypes.py
index d796aae..ce184e1 100644
--- a/src/metastore/src/gen/thrift/gen-py/hive_metastore/ttypes.py
+++ b/src/metastore/src/gen/thrift/gen-py/hive_metastore/ttypes.py
@@ -2648,6 +2648,189 @@ def __eq__(self, other):
   def __ne__(self, other):
     return not (self == other)
 
+class Decimal:
+  """
+  Attributes:
+   - unscaled
+   - scale
+  """
+
+  thrift_spec = (
+    None, # 0
+    (1, TType.STRING, 'unscaled', None, None, ), # 1
+    None, # 2
+    (3, TType.I16, 'scale', None, None, ), # 3
+  )
+
+  def __init__(self, unscaled=None, scale=None,):
+    self.unscaled = unscaled
+    self.scale = scale
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 1:
+        if ftype == TType.STRING:
+          self.unscaled = iprot.readString();
+        else:
+          iprot.skip(ftype)
+      elif fid == 3:
+        if ftype == TType.I16:
+          self.scale = iprot.readI16();
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('Decimal')
+    if self.unscaled is not None:
+      oprot.writeFieldBegin('unscaled', TType.STRING, 1)
+      oprot.writeString(self.unscaled)
+      oprot.writeFieldEnd()
+    if self.scale is not None:
+      oprot.writeFieldBegin('scale', TType.I16, 3)
+      oprot.writeI16(self.scale)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    if self.unscaled is None:
+      raise TProtocol.TProtocolException(message='Required field unscaled is unset!')
+    if self.scale is None:
+      raise TProtocol.TProtocolException(message='Required field scale is unset!')
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
+
+class DecimalColumnStatsData:
+  """
+  Attributes:
+   - lowValue
+   - highValue
+   - numNulls
+   - numDVs
+  """
+
+  thrift_spec = (
+    None, # 0
+    (1, TType.STRUCT, 'lowValue', (Decimal, Decimal.thrift_spec), None, ), # 1
+    (2, TType.STRUCT, 'highValue', (Decimal, Decimal.thrift_spec), None, ), # 2
+    (3, TType.I64, 'numNulls', None, None, ), # 3
+    (4, TType.I64, 'numDVs', None, None, ), # 4
+  )
+
+  def __init__(self, lowValue=None, highValue=None, numNulls=None, numDVs=None,):
+    self.lowValue = lowValue
+    self.highValue = highValue
+    self.numNulls = numNulls
+    self.numDVs = numDVs
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 1:
+        if ftype == TType.STRUCT:
+          self.lowValue = Decimal()
+          self.lowValue.read(iprot)
+        else:
+          iprot.skip(ftype)
+      elif fid == 2:
+        if ftype == TType.STRUCT:
+          self.highValue = Decimal()
+          self.highValue.read(iprot)
+        else:
+          iprot.skip(ftype)
+      elif fid == 3:
+        if ftype == TType.I64:
+          self.numNulls = iprot.readI64();
+        else:
+          iprot.skip(ftype)
+      elif fid == 4:
+        if ftype == TType.I64:
+          self.numDVs = iprot.readI64();
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('DecimalColumnStatsData')
+    if self.lowValue is not None:
+      oprot.writeFieldBegin('lowValue', TType.STRUCT, 1)
+      self.lowValue.write(oprot)
+      oprot.writeFieldEnd()
+    if self.highValue is not None:
+      oprot.writeFieldBegin('highValue', TType.STRUCT, 2)
+      self.highValue.write(oprot)
+      oprot.writeFieldEnd()
+    if self.numNulls is not None:
+      oprot.writeFieldBegin('numNulls', TType.I64, 3)
+      oprot.writeI64(self.numNulls)
+      oprot.writeFieldEnd()
+    if self.numDVs is not None:
+      oprot.writeFieldBegin('numDVs', TType.I64, 4)
+      oprot.writeI64(self.numDVs)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    if self.lowValue is None:
+      raise TProtocol.TProtocolException(message='Required field lowValue is unset!')
+    if self.highValue is None:
+      raise TProtocol.TProtocolException(message='Required field highValue is unset!')
+    if self.numNulls is None:
+      raise TProtocol.TProtocolException(message='Required field numNulls is unset!')
+    if self.numDVs is None:
+      raise TProtocol.TProtocolException(message='Required field numDVs is unset!')
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
+
 class ColumnStatisticsData:
   """
   Attributes:
@@ -2656,6 +2839,7 @@ class ColumnStatisticsData:
    - doubleStats
    - stringStats
    - binaryStats
+   - decimalStats
   """
 
   thrift_spec = (
@@ -2665,14 +2849,16 @@ class ColumnStatisticsData:
     (3, TType.STRUCT, 'doubleStats', (DoubleColumnStatsData, DoubleColumnStatsData.thrift_spec), None, ), # 3
     (4, TType.STRUCT, 'stringStats', (StringColumnStatsData, StringColumnStatsData.thrift_spec), None, ), # 4
     (5, TType.STRUCT, 'binaryStats', (BinaryColumnStatsData, BinaryColumnStatsData.thrift_spec), None, ), # 5
+    (6, TType.STRUCT, 'decimalStats', (DecimalColumnStatsData, DecimalColumnStatsData.thrift_spec), None, ), # 6
   )
 
-  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None,):
+  def __init__(self, booleanStats=None, longStats=None, doubleStats=None, stringStats=None, binaryStats=None, decimalStats=None,):
     self.booleanStats = booleanStats
     self.longStats = longStats
     self.doubleStats = doubleStats
     self.stringStats = stringStats
     self.binaryStats = binaryStats
+    self.decimalStats = decimalStats
 
   def read(self, iprot):
     if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
@@ -2713,6 +2899,12 @@ def read(self, iprot):
           self.binaryStats.read(iprot)
         else:
           iprot.skip(ftype)
+      elif fid == 6:
+        if ftype == TType.STRUCT:
+          self.decimalStats = DecimalColumnStatsData()
+          self.decimalStats.read(iprot)
+        else:
+          iprot.skip(ftype)
       else:
         iprot.skip(ftype)
       iprot.readFieldEnd()
@@ -2743,6 +2935,10 @@ def write(self, oprot):
       oprot.writeFieldBegin('binaryStats', TType.STRUCT, 5)
       self.binaryStats.write(oprot)
       oprot.writeFieldEnd()
+    if self.decimalStats is not None:
+      oprot.writeFieldBegin('decimalStats', TType.STRUCT, 6)
+      self.decimalStats.write(oprot)
+      oprot.writeFieldEnd()
     oprot.writeFieldStop()
     oprot.writeStructEnd()
 
diff --git a/src/metastore/src/gen/thrift/gen-rb/hive_metastore_types.rb b/src/metastore/src/gen/thrift/gen-rb/hive_metastore_types.rb
index 616e5b3..f4c8cf8 100644
--- a/src/metastore/src/gen/thrift/gen-rb/hive_metastore_types.rb
+++ b/src/metastore/src/gen/thrift/gen-rb/hive_metastore_types.rb
@@ -575,6 +575,52 @@ class BinaryColumnStatsData
   ::Thrift::Struct.generate_accessors self
 end
 
+class Decimal
+  include ::Thrift::Struct, ::Thrift::Struct_Union
+  UNSCALED = 1
+  SCALE = 3
+
+  FIELDS = {
+    UNSCALED => {:type => ::Thrift::Types::STRING, :name => 'unscaled', :binary => true},
+    SCALE => {:type => ::Thrift::Types::I16, :name => 'scale'}
+  }
+
+  def struct_fields; FIELDS; end
+
+  def validate
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unscaled is unset!') unless @unscaled
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scale is unset!') unless @scale
+  end
+
+  ::Thrift::Struct.generate_accessors self
+end
+
+class DecimalColumnStatsData
+  include ::Thrift::Struct, ::Thrift::Struct_Union
+  LOWVALUE = 1
+  HIGHVALUE = 2
+  NUMNULLS = 3
+  NUMDVS = 4
+
+  FIELDS = {
+    LOWVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'lowValue', :class => ::Decimal},
+    HIGHVALUE => {:type => ::Thrift::Types::STRUCT, :name => 'highValue', :class => ::Decimal},
+    NUMNULLS => {:type => ::Thrift::Types::I64, :name => 'numNulls'},
+    NUMDVS => {:type => ::Thrift::Types::I64, :name => 'numDVs'}
+  }
+
+  def struct_fields; FIELDS; end
+
+  def validate
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field lowValue is unset!') unless @lowValue
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field highValue is unset!') unless @highValue
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numNulls is unset!') unless @numNulls
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field numDVs is unset!') unless @numDVs
+  end
+
+  ::Thrift::Struct.generate_accessors self
+end
+
 class ColumnStatisticsData < ::Thrift::Union
   include ::Thrift::Struct_Union
   class << self
@@ -597,6 +643,10 @@ class ColumnStatisticsData < ::Thrift::Union
     def binaryStats(val)
       ColumnStatisticsData.new(:binaryStats, val)
     end
+
+    def decimalStats(val)
+      ColumnStatisticsData.new(:decimalStats, val)
+    end
   end
 
   BOOLEANSTATS = 1
@@ -604,13 +654,15 @@ class ColumnStatisticsData < ::Thrift::Union
   DOUBLESTATS = 3
   STRINGSTATS = 4
   BINARYSTATS = 5
+  DECIMALSTATS = 6
 
   FIELDS = {
     BOOLEANSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'booleanStats', :class => ::BooleanColumnStatsData},
     LONGSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'longStats', :class => ::LongColumnStatsData},
     DOUBLESTATS => {:type => ::Thrift::Types::STRUCT, :name => 'doubleStats', :class => ::DoubleColumnStatsData},
     STRINGSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'stringStats', :class => ::StringColumnStatsData},
-    BINARYSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'binaryStats', :class => ::BinaryColumnStatsData}
+    BINARYSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'binaryStats', :class => ::BinaryColumnStatsData},
+    DECIMALSTATS => {:type => ::Thrift::Types::STRUCT, :name => 'decimalStats', :class => ::DecimalColumnStatsData}
   }
 
   def struct_fields; FIELDS; end
diff --git a/src/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java b/src/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
index 102e876..1dd8ead 100644
--- a/src/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
+++ b/src/metastore/src/java/org/apache/hadoop/hive/metastore/MetaStoreDirectSql.java
@@ -23,7 +23,6 @@
 
 import java.sql.Connection;
 import java.sql.SQLException;
-import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -38,6 +37,10 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.metastore.api.ColumnStatistics;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsData;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsDesc;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsObj;
 import org.apache.hadoop.hive.metastore.api.FieldSchema;
 import org.apache.hadoop.hive.metastore.api.MetaException;
 import org.apache.hadoop.hive.metastore.api.Order;
@@ -56,6 +59,8 @@
 import org.apache.hadoop.hive.metastore.parser.ExpressionTree.TreeVisitor;
 import org.apache.hadoop.hive.serde.serdeConstants;
 
+import com.google.common.collect.Lists;
+
 /**
  * This class contains the optimizations for MetaStore that rely on direct SQL access to
  * the underlying database. It should use ANSI SQL and be compatible with common databases
@@ -781,4 +786,136 @@ public void visit(LeafNode node) throws MetaException {
           : "(" + tableValue + " " + node.operator.getSqlOp() + " ?)");
     }
   }
+
+  public ColumnStatistics getTableStats(
+      String dbName, String tableName, List<String> colNames) throws MetaException {
+    if (colNames.isEmpty()) {
+      return null;
+    }
+    boolean doTrace = LOG.isDebugEnabled();
+    long start = doTrace ? System.nanoTime() : 0;
+    String queryText = "select " + STATS_COLLIST + " from \"TAB_COL_STATS\" "
+      + " where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and \"COLUMN_NAME\" in ("
+      + makeParams(colNames.size()) + ")";
+    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
+    Object[] params = new Object[colNames.size() + 2];
+    params[0] = dbName;
+    params[1] = tableName;
+    for (int i = 0; i < colNames.size(); ++i) {
+      params[i + 2] = colNames.get(i);
+    }
+    Object qResult = query.executeWithArray(params);
+    long queryTime = doTrace ? System.nanoTime() : 0;
+    if (qResult == null) {
+      query.closeAll();
+      return null;
+    }
+    List<Object[]> list = ensureList(qResult);
+    if (list.isEmpty()) return null;
+    ColumnStatisticsDesc csd = new ColumnStatisticsDesc(true, dbName, tableName);
+    ColumnStatistics result = makeColumnStats(list, csd, 0);
+    timingTrace(doTrace, queryText, start, queryTime);
+    query.closeAll();
+    return result;
+  }
+
+  public List<ColumnStatistics> getPartitionStats(String dbName, String tableName,
+      List<String> partNames, List<String> colNames) throws MetaException {
+    if (colNames.isEmpty() || partNames.isEmpty()) {
+      return Lists.newArrayList();
+    }
+    boolean doTrace = LOG.isDebugEnabled();
+    long start = doTrace ? System.nanoTime() : 0;
+    String queryText = "select \"PARTITION_NAME\", " + STATS_COLLIST + " from \"PART_COL_STATS\""
+      + " where \"DB_NAME\" = ? and \"TABLE_NAME\" = ? and \"COLUMN_NAME\" in ("
+      + makeParams(colNames.size()) + ") AND \"PARTITION_NAME\" in ("
+      + makeParams(partNames.size()) + ") order by \"PARTITION_NAME\"";
+
+    Query query = pm.newQuery("javax.jdo.query.SQL", queryText);
+    Object[] params = new Object[colNames.size() + partNames.size() + 2];
+    int paramI = 0;
+    params[paramI++] = dbName;
+    params[paramI++] = tableName;
+    for (String colName : colNames) {
+      params[paramI++] = colName;
+    }
+    for (String partName : partNames) {
+      params[paramI++] = partName;
+    }
+    Object qResult = query.executeWithArray(params);
+    long queryTime = doTrace ? System.nanoTime() : 0;
+    if (qResult == null) {
+      query.closeAll();
+      return Lists.newArrayList();
+    }
+    List<Object[]> list = ensureList(qResult);
+    List<ColumnStatistics> result = new ArrayList<ColumnStatistics>(
+        Math.min(list.size(), partNames.size()));
+    String lastPartName = null;
+    int from = 0;
+    for (int i = 0; i <= list.size(); ++i) {
+      boolean isLast = i == list.size();
+      String partName = isLast ? null : (String)list.get(i)[0];
+      if (!isLast && partName.equals(lastPartName)) {
+        continue;
+      } else if (from != i) {
+        ColumnStatisticsDesc csd = new ColumnStatisticsDesc(false, dbName, tableName);
+        csd.setPartName(lastPartName);
+        result.add(makeColumnStats(list.subList(from, i), csd, 1));
+      }
+      lastPartName = partName;
+      from = i;
+    }
+
+    timingTrace(doTrace, queryText, start, queryTime);
+    query.closeAll();
+    return result;
+  }
+
+  /** The common query part for table and partition stats */
+  private static final String STATS_COLLIST =
+      "\"COLUMN_NAME\", \"COLUMN_TYPE\", \"LONG_LOW_VALUE\", \"LONG_HIGH_VALUE\", "
+    + "\"DOUBLE_LOW_VALUE\", \"DOUBLE_HIGH_VALUE\", \"BIG_DECIMAL_LOW_VALUE\", "
+    + "\"BIG_DECIMAL_HIGH_VALUE\", \"NUM_NULLS\", \"NUM_DISTINCTS\", \"AVG_COL_LEN\", "
+    + "\"MAX_COL_LEN\", \"NUM_TRUES\", \"NUM_FALSES\", \"LAST_ANALYZED\" ";
+
+  private ColumnStatistics makeColumnStats(
+      List<Object[]> list, ColumnStatisticsDesc csd, int offset) {
+    ColumnStatistics result = new ColumnStatistics();
+    result.setStatsDesc(csd);
+    List<ColumnStatisticsObj> csos = new ArrayList<ColumnStatisticsObj>(list.size());
+    for (Object[] row : list) {
+      // LastAnalyzed is stored per column but thrift has it per several;
+      // get the lowest for now as nobody actually uses this field.
+      Object laObj = row[offset + 14];
+      if (laObj != null && (!csd.isSetLastAnalyzed() || csd.getLastAnalyzed() > (Long)laObj)) {
+        csd.setLastAnalyzed((Long)laObj);
+      }
+      ColumnStatisticsData data = new ColumnStatisticsData();
+      // see STATS_COLLIST
+      int i = offset;
+      ColumnStatisticsObj cso = new ColumnStatisticsObj((String)row[i++], (String)row[i++], data);
+      Object llow = row[i++], lhigh = row[i++], dlow = row[i++], dhigh = row[i++],
+          declow = row[i++], dechigh = row[i++], nulls = row[i++], dist = row[i++],
+          avglen = row[i++], maxlen = row[i++], trues = row[i++], falses = row[i++];
+      StatObjectConverter.fillColumnStatisticsData(cso.getColType(), data,
+          llow, lhigh, dlow, dhigh, declow, dechigh, nulls, dist, avglen, maxlen, trues, falses);
+      csos.add(cso);
+    }
+    result.setStatsObj(csos);
+    return result;
+  }
+
+  @SuppressWarnings("unchecked")
+  private List<Object[]> ensureList(Object result) throws MetaException {
+    if (!(result instanceof List<?>)) {
+      throw new MetaException("Wrong result type " + result.getClass());
+    }
+    return (List<Object[]>)result;
+  }
+
+  private String makeParams(int size) {
+    // W/ size 0, query will fail, but at least we'd get to see the query in debug output.
+    return (size == 0) ? "" : repeat(",?", size).substring(1);
+  }
 }
diff --git a/src/metastore/src/java/org/apache/hadoop/hive/metastore/StatObjectConverter.java b/src/metastore/src/java/org/apache/hadoop/hive/metastore/StatObjectConverter.java
new file mode 100644
index 0000000..dc0e266
--- /dev/null
+++ b/src/metastore/src/java/org/apache/hadoop/hive/metastore/StatObjectConverter.java
@@ -0,0 +1,369 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.metastore;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.hive.metastore.api.BinaryColumnStatsData;
+import org.apache.hadoop.hive.metastore.api.BooleanColumnStatsData;
+import org.apache.hadoop.hive.metastore.api.ColumnStatistics;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsData;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsDesc;
+import org.apache.hadoop.hive.metastore.api.ColumnStatisticsObj;
+import org.apache.hadoop.hive.metastore.api.Decimal;
+import org.apache.hadoop.hive.metastore.api.DecimalColumnStatsData;
+import org.apache.hadoop.hive.metastore.api.DoubleColumnStatsData;
+import org.apache.hadoop.hive.metastore.api.InvalidObjectException;
+import org.apache.hadoop.hive.metastore.api.LongColumnStatsData;
+import org.apache.hadoop.hive.metastore.api.MetaException;
+import org.apache.hadoop.hive.metastore.api.NoSuchObjectException;
+import org.apache.hadoop.hive.metastore.api.StringColumnStatsData;
+import org.apache.hadoop.hive.metastore.model.MFieldSchema;
+import org.apache.hadoop.hive.metastore.model.MPartition;
+import org.apache.hadoop.hive.metastore.model.MPartitionColumnStatistics;
+import org.apache.hadoop.hive.metastore.model.MStorageDescriptor;
+import org.apache.hadoop.hive.metastore.model.MTable;
+import org.apache.hadoop.hive.metastore.model.MTableColumnStatistics;
+
+/**
+ * This class contains conversion logic that creates Thrift stat objects from
+ * JDO stat objects and plain arrays from DirectSQL.
+ * It is hidden here so that we wouldn't have to look at it in elsewhere.
+ */
+public class StatObjectConverter {
+  // JDO
+  public static MTableColumnStatistics convertToMTableColumnStatistics(MTable table,
+      ColumnStatisticsDesc statsDesc, ColumnStatisticsObj statsObj)
+          throws NoSuchObjectException, MetaException, InvalidObjectException {
+     if (statsObj == null || statsDesc == null) {
+       throw new InvalidObjectException("Invalid column stats object");
+     }
+
+     MTableColumnStatistics mColStats = new MTableColumnStatistics();
+     mColStats.setTable(table);
+     mColStats.setDbName(statsDesc.getDbName());
+     mColStats.setTableName(statsDesc.getTableName());
+     mColStats.setLastAnalyzed(statsDesc.getLastAnalyzed());
+     mColStats.setColName(statsObj.getColName());
+     mColStats.setColType(statsObj.getColType());
+
+     if (statsObj.getStatsData().isSetBooleanStats()) {
+       BooleanColumnStatsData boolStats = statsObj.getStatsData().getBooleanStats();
+       mColStats.setBooleanStats(boolStats.getNumTrues(), boolStats.getNumFalses(),
+           boolStats.getNumNulls());
+     } else if (statsObj.getStatsData().isSetLongStats()) {
+       LongColumnStatsData longStats = statsObj.getStatsData().getLongStats();
+       mColStats.setLongStats(longStats.getNumNulls(), longStats.getNumDVs(),
+           longStats.getLowValue(), longStats.getHighValue());
+     } else if (statsObj.getStatsData().isSetDoubleStats()) {
+       DoubleColumnStatsData doubleStats = statsObj.getStatsData().getDoubleStats();
+       mColStats.setDoubleStats(doubleStats.getNumNulls(), doubleStats.getNumDVs(),
+           doubleStats.getLowValue(), doubleStats.getHighValue());
+     } else if (statsObj.getStatsData().isSetDecimalStats()) {
+       DecimalColumnStatsData decimalStats = statsObj.getStatsData().getDecimalStats();
+       String low = createJdoDecimalString(decimalStats.getLowValue()),
+           high = createJdoDecimalString(decimalStats.getHighValue());
+       mColStats.setDecimalStats(decimalStats.getNumNulls(), decimalStats.getNumDVs(), low, high);
+     } else if (statsObj.getStatsData().isSetStringStats()) {
+       StringColumnStatsData stringStats = statsObj.getStatsData().getStringStats();
+       mColStats.setStringStats(stringStats.getNumNulls(), stringStats.getNumDVs(),
+         stringStats.getMaxColLen(), stringStats.getAvgColLen());
+     } else if (statsObj.getStatsData().isSetBinaryStats()) {
+       BinaryColumnStatsData binaryStats = statsObj.getStatsData().getBinaryStats();
+       mColStats.setBinaryStats(binaryStats.getNumNulls(), binaryStats.getMaxColLen(),
+         binaryStats.getAvgColLen());
+     }
+     return mColStats;
+  }
+
+  public static void setFieldsIntoOldStats(
+      MTableColumnStatistics mStatsObj, MTableColumnStatistics oldStatsObj) {
+    oldStatsObj.setAvgColLen(mStatsObj.getAvgColLen());
+    oldStatsObj.setLongHighValue(mStatsObj.getLongHighValue());
+    oldStatsObj.setDoubleHighValue(mStatsObj.getDoubleHighValue());
+    oldStatsObj.setLastAnalyzed(mStatsObj.getLastAnalyzed());
+    oldStatsObj.setLongLowValue(mStatsObj.getLongLowValue());
+    oldStatsObj.setDoubleLowValue(mStatsObj.getDoubleLowValue());
+    oldStatsObj.setDecimalLowValue(mStatsObj.getDecimalLowValue());
+    oldStatsObj.setDecimalHighValue(mStatsObj.getDecimalHighValue());
+    oldStatsObj.setMaxColLen(mStatsObj.getMaxColLen());
+    oldStatsObj.setNumDVs(mStatsObj.getNumDVs());
+    oldStatsObj.setNumFalses(mStatsObj.getNumFalses());
+    oldStatsObj.setNumTrues(mStatsObj.getNumTrues());
+    oldStatsObj.setNumNulls(mStatsObj.getNumNulls());
+  }
+
+  public static void setFieldsIntoOldStats(
+      MPartitionColumnStatistics mStatsObj, MPartitionColumnStatistics oldStatsObj) {
+    oldStatsObj.setAvgColLen(mStatsObj.getAvgColLen());
+    oldStatsObj.setLongHighValue(mStatsObj.getLongHighValue());
+    oldStatsObj.setDoubleHighValue(mStatsObj.getDoubleHighValue());
+    oldStatsObj.setLastAnalyzed(mStatsObj.getLastAnalyzed());
+    oldStatsObj.setLongLowValue(mStatsObj.getLongLowValue());
+    oldStatsObj.setDoubleLowValue(mStatsObj.getDoubleLowValue());
+    oldStatsObj.setDecimalLowValue(mStatsObj.getDecimalLowValue());
+    oldStatsObj.setDecimalHighValue(mStatsObj.getDecimalHighValue());
+    oldStatsObj.setMaxColLen(mStatsObj.getMaxColLen());
+    oldStatsObj.setNumDVs(mStatsObj.getNumDVs());
+    oldStatsObj.setNumFalses(mStatsObj.getNumFalses());
+    oldStatsObj.setNumTrues(mStatsObj.getNumTrues());
+    oldStatsObj.setNumNulls(mStatsObj.getNumNulls());
+  }
+
+  public static ColumnStatisticsObj getTableColumnStatisticsObj(
+      MTableColumnStatistics mStatsObj) {
+    ColumnStatisticsObj statsObj = new ColumnStatisticsObj();
+    statsObj.setColType(mStatsObj.getColType());
+    statsObj.setColName(mStatsObj.getColName());
+    String colType = mStatsObj.getColType().toLowerCase();
+    ColumnStatisticsData colStatsData = new ColumnStatisticsData();
+
+    if (colType.equals("boolean")) {
+      BooleanColumnStatsData boolStats = new BooleanColumnStatsData();
+      boolStats.setNumFalses(mStatsObj.getNumFalses());
+      boolStats.setNumTrues(mStatsObj.getNumTrues());
+      boolStats.setNumNulls(mStatsObj.getNumNulls());
+      colStatsData.setBooleanStats(boolStats);
+    } else if (colType.equals("string") ||
+        colType.startsWith("varchar") || colType.startsWith("char")) {
+      StringColumnStatsData stringStats = new StringColumnStatsData();
+      stringStats.setNumNulls(mStatsObj.getNumNulls());
+      stringStats.setAvgColLen(mStatsObj.getAvgColLen());
+      stringStats.setMaxColLen(mStatsObj.getMaxColLen());
+      stringStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setStringStats(stringStats);
+    } else if (colType.equals("binary")) {
+      BinaryColumnStatsData binaryStats = new BinaryColumnStatsData();
+      binaryStats.setNumNulls(mStatsObj.getNumNulls());
+      binaryStats.setAvgColLen(mStatsObj.getAvgColLen());
+      binaryStats.setMaxColLen(mStatsObj.getMaxColLen());
+      colStatsData.setBinaryStats(binaryStats);
+    } else if (colType.equals("bigint") || colType.equals("int") ||
+        colType.equals("smallint") || colType.equals("tinyint") ||
+        colType.equals("timestamp")) {
+      LongColumnStatsData longStats = new LongColumnStatsData();
+      longStats.setNumNulls(mStatsObj.getNumNulls());
+      longStats.setHighValue(mStatsObj.getLongHighValue());
+      longStats.setLowValue(mStatsObj.getLongLowValue());
+      longStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setLongStats(longStats);
+    } else if (colType.equals("double") || colType.equals("float")) {
+      DoubleColumnStatsData doubleStats = new DoubleColumnStatsData();
+      doubleStats.setNumNulls(mStatsObj.getNumNulls());
+      doubleStats.setHighValue(mStatsObj.getDoubleHighValue());
+      doubleStats.setLowValue(mStatsObj.getDoubleLowValue());
+      doubleStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setDoubleStats(doubleStats);
+    } else if (colType.equals("decimal")) {
+      DecimalColumnStatsData decimalStats = new DecimalColumnStatsData();
+      decimalStats.setNumNulls(mStatsObj.getNumNulls());
+      decimalStats.setHighValue(createThriftDecimal(mStatsObj.getDecimalHighValue()));
+      decimalStats.setLowValue(createThriftDecimal(mStatsObj.getDecimalLowValue()));
+      decimalStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setDecimalStats(decimalStats);
+    }
+    statsObj.setStatsData(colStatsData);
+    return statsObj;
+  }
+
+  public static ColumnStatisticsDesc getTableColumnStatisticsDesc(
+      MTableColumnStatistics mStatsObj) {
+    ColumnStatisticsDesc statsDesc = new ColumnStatisticsDesc();
+    statsDesc.setIsTblLevel(true);
+    statsDesc.setDbName(mStatsObj.getDbName());
+    statsDesc.setTableName(mStatsObj.getTableName());
+    statsDesc.setLastAnalyzed(mStatsObj.getLastAnalyzed());
+    return statsDesc;
+  }
+
+  public static MPartitionColumnStatistics convertToMPartitionColumnStatistics(
+      MPartition partition, ColumnStatisticsDesc statsDesc, ColumnStatisticsObj statsObj)
+          throws MetaException, NoSuchObjectException {
+    if (statsDesc == null || statsObj == null) {
+      return null;
+    }
+
+    MPartitionColumnStatistics mColStats = new MPartitionColumnStatistics();
+    mColStats.setPartition(partition);
+    mColStats.setDbName(statsDesc.getDbName());
+    mColStats.setTableName(statsDesc.getTableName());
+    mColStats.setPartitionName(statsDesc.getPartName());
+    mColStats.setLastAnalyzed(statsDesc.getLastAnalyzed());
+    mColStats.setColName(statsObj.getColName());
+    mColStats.setColType(statsObj.getColType());
+
+    if (statsObj.getStatsData().isSetBooleanStats()) {
+      BooleanColumnStatsData boolStats = statsObj.getStatsData().getBooleanStats();
+      mColStats.setBooleanStats(boolStats.getNumTrues(), boolStats.getNumFalses(),
+          boolStats.getNumNulls());
+    } else if (statsObj.getStatsData().isSetLongStats()) {
+      LongColumnStatsData longStats = statsObj.getStatsData().getLongStats();
+      mColStats.setLongStats(longStats.getNumNulls(), longStats.getNumDVs(),
+          longStats.getLowValue(), longStats.getHighValue());
+    } else if (statsObj.getStatsData().isSetDoubleStats()) {
+      DoubleColumnStatsData doubleStats = statsObj.getStatsData().getDoubleStats();
+      mColStats.setDoubleStats(doubleStats.getNumNulls(), doubleStats.getNumDVs(),
+          doubleStats.getLowValue(), doubleStats.getHighValue());
+    } else if (statsObj.getStatsData().isSetDecimalStats()) {
+      DecimalColumnStatsData decimalStats = statsObj.getStatsData().getDecimalStats();
+      String low = createJdoDecimalString(decimalStats.getLowValue()),
+          high = createJdoDecimalString(decimalStats.getHighValue());
+      mColStats.setDecimalStats(decimalStats.getNumNulls(), decimalStats.getNumDVs(), low, high);
+    } else if (statsObj.getStatsData().isSetStringStats()) {
+      StringColumnStatsData stringStats = statsObj.getStatsData().getStringStats();
+      mColStats.setStringStats(stringStats.getNumNulls(), stringStats.getNumDVs(),
+        stringStats.getMaxColLen(), stringStats.getAvgColLen());
+    } else if (statsObj.getStatsData().isSetBinaryStats()) {
+      BinaryColumnStatsData binaryStats = statsObj.getStatsData().getBinaryStats();
+      mColStats.setBinaryStats(binaryStats.getNumNulls(), binaryStats.getMaxColLen(),
+        binaryStats.getAvgColLen());
+    }
+    return mColStats;
+  }
+
+  public static ColumnStatisticsObj getPartitionColumnStatisticsObj(
+      MPartitionColumnStatistics mStatsObj) {
+    ColumnStatisticsObj statsObj = new ColumnStatisticsObj();
+    statsObj.setColType(mStatsObj.getColType());
+    statsObj.setColName(mStatsObj.getColName());
+    String colType = mStatsObj.getColType().toLowerCase();
+    ColumnStatisticsData colStatsData = new ColumnStatisticsData();
+
+    if (colType.equals("boolean")) {
+      BooleanColumnStatsData boolStats = new BooleanColumnStatsData();
+      boolStats.setNumFalses(mStatsObj.getNumFalses());
+      boolStats.setNumTrues(mStatsObj.getNumTrues());
+      boolStats.setNumNulls(mStatsObj.getNumNulls());
+      colStatsData.setBooleanStats(boolStats);
+    } else if (colType.equals("string") ||
+        colType.startsWith("varchar") || colType.startsWith("char")) {
+      StringColumnStatsData stringStats = new StringColumnStatsData();
+      stringStats.setNumNulls(mStatsObj.getNumNulls());
+      stringStats.setAvgColLen(mStatsObj.getAvgColLen());
+      stringStats.setMaxColLen(mStatsObj.getMaxColLen());
+      stringStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setStringStats(stringStats);
+    } else if (colType.equals("binary")) {
+      BinaryColumnStatsData binaryStats = new BinaryColumnStatsData();
+      binaryStats.setNumNulls(mStatsObj.getNumNulls());
+      binaryStats.setAvgColLen(mStatsObj.getAvgColLen());
+      binaryStats.setMaxColLen(mStatsObj.getMaxColLen());
+      colStatsData.setBinaryStats(binaryStats);
+    } else if (colType.equals("tinyint") || colType.equals("smallint") ||
+        colType.equals("int") || colType.equals("bigint") ||
+        colType.equals("timestamp")) {
+      LongColumnStatsData longStats = new LongColumnStatsData();
+      longStats.setNumNulls(mStatsObj.getNumNulls());
+      longStats.setHighValue(mStatsObj.getLongHighValue());
+      longStats.setLowValue(mStatsObj.getLongLowValue());
+      longStats.setNumDVs(mStatsObj.getNumDVs());
+      colStatsData.setLongStats(longStats);
+   } else if (colType.equals("double") || colType.equals("float")) {
+     DoubleColumnStatsData doubleStats = new DoubleColumnStatsData();
+     doubleStats.setNumNulls(mStatsObj.getNumNulls());
+     doubleStats.setHighValue(mStatsObj.getDoubleHighValue());
+     doubleStats.setLowValue(mStatsObj.getDoubleLowValue());
+     doubleStats.setNumDVs(mStatsObj.getNumDVs());
+     colStatsData.setDoubleStats(doubleStats);
+   } else if (colType.equals("decimal")) {
+     DecimalColumnStatsData decimalStats = new DecimalColumnStatsData();
+     decimalStats.setNumNulls(mStatsObj.getNumNulls());
+     decimalStats.setHighValue(createThriftDecimal(mStatsObj.getDecimalHighValue()));
+     decimalStats.setLowValue(createThriftDecimal(mStatsObj.getDecimalLowValue()));
+     decimalStats.setNumDVs(mStatsObj.getNumDVs());
+     colStatsData.setDecimalStats(decimalStats);
+   }
+   statsObj.setStatsData(colStatsData);
+   return statsObj;
+  }
+
+  public static ColumnStatisticsDesc getPartitionColumnStatisticsDesc(
+    MPartitionColumnStatistics mStatsObj) {
+    ColumnStatisticsDesc statsDesc = new ColumnStatisticsDesc();
+    statsDesc.setIsTblLevel(false);
+    statsDesc.setDbName(mStatsObj.getDbName());
+    statsDesc.setTableName(mStatsObj.getTableName());
+    statsDesc.setPartName(mStatsObj.getPartitionName());
+    statsDesc.setLastAnalyzed(mStatsObj.getLastAnalyzed());
+    return statsDesc;
+  }
+
+  // SQL
+  public static void fillColumnStatisticsData(String colType, ColumnStatisticsData data,
+      Object llow, Object lhigh, Object dlow, Object dhigh, Object declow, Object dechigh,
+      Object nulls, Object dist, Object avglen, Object maxlen, Object trues, Object falses) {
+    if (colType.equals("boolean")) {
+      BooleanColumnStatsData boolStats = new BooleanColumnStatsData();
+      boolStats.setNumFalses((Long)falses);
+      boolStats.setNumTrues((Long)trues);
+      boolStats.setNumNulls((Long)nulls);
+      data.setBooleanStats(boolStats);
+    } else if (colType.equals("string") ||
+        colType.startsWith("varchar") || colType.startsWith("char")) {
+      StringColumnStatsData stringStats = new StringColumnStatsData();
+      stringStats.setNumNulls((Long)nulls);
+      stringStats.setAvgColLen((Double)avglen);
+      stringStats.setMaxColLen((Long)maxlen);
+      stringStats.setNumDVs((Long)dist);
+      data.setStringStats(stringStats);
+    } else if (colType.equals("binary")) {
+      BinaryColumnStatsData binaryStats = new BinaryColumnStatsData();
+      binaryStats.setNumNulls((Long)nulls);
+      binaryStats.setAvgColLen((Double)avglen);
+      binaryStats.setMaxColLen((Long)maxlen);
+      data.setBinaryStats(binaryStats);
+    } else if (colType.equals("bigint") || colType.equals("int") ||
+        colType.equals("smallint") || colType.equals("tinyint") ||
+        colType.equals("timestamp")) {
+      LongColumnStatsData longStats = new LongColumnStatsData();
+      longStats.setNumNulls((Long)nulls);
+      longStats.setHighValue((Long)lhigh);
+      longStats.setLowValue((Long)llow);
+      longStats.setNumDVs((Long)dist);
+      data.setLongStats(longStats);
+    } else if (colType.equals("double") || colType.equals("float")) {
+      DoubleColumnStatsData doubleStats = new DoubleColumnStatsData();
+      doubleStats.setNumNulls((Long)nulls);
+      doubleStats.setHighValue((Double)dhigh);
+      doubleStats.setLowValue((Double)dlow);
+      doubleStats.setNumDVs((Long)dist);
+      data.setDoubleStats(doubleStats);
+    } else if (colType.equals("decimal")) {
+      DecimalColumnStatsData decimalStats = new DecimalColumnStatsData();
+      decimalStats.setNumNulls((Long)nulls);
+      decimalStats.setHighValue(createThriftDecimal((String)dechigh));
+      decimalStats.setLowValue(createThriftDecimal((String)declow));
+      decimalStats.setNumDVs((Long)dist);
+      data.setDecimalStats(decimalStats);
+    }
+  }
+
+  private static Decimal createThriftDecimal(String s) {
+    BigDecimal d = new BigDecimal(s);
+    return new Decimal(ByteBuffer.wrap(d.unscaledValue().toByteArray()), (short)d.scale());
+  }
+
+  private static String createJdoDecimalString(Decimal d) {
+    return new BigDecimal(new BigInteger(d.getUnscaled()), d.getScale()).toString();
+  }
+}
diff --git a/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MPartitionColumnStatistics.java b/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MPartitionColumnStatistics.java
index eb23cf9..f61cdf0 100644
--- a/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MPartitionColumnStatistics.java
+++ b/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MPartitionColumnStatistics.java
@@ -44,6 +44,8 @@
   private long longHighValue;
   private double doubleLowValue;
   private double doubleHighValue;
+  private String decimalLowValue;
+  private String decimalHighValue;
   private long numNulls;
   private long numDVs;
   private double avgColLen;
@@ -178,6 +180,14 @@ public void setDoubleStats(long numNulls, long numNDVs, double lowValue, double 
     this.doubleHighValue = highValue;
   }
 
+  public void setDecimalStats(
+      long numNulls, long numNDVs, String lowValue, String highValue) {
+    this.numNulls = numNulls;
+    this.numDVs = numNDVs;
+    this.decimalLowValue = lowValue;
+    this.decimalHighValue = highValue;
+  }
+
   public void setStringStats(long numNulls, long numNDVs, long maxColLen, double avgColLen) {
     this.numNulls = numNulls;
     this.numDVs = numNDVs;
@@ -221,4 +231,20 @@ public double getDoubleHighValue() {
   public void setDoubleHighValue(double doubleHighValue) {
     this.doubleHighValue = doubleHighValue;
   }
+
+  public String getDecimalLowValue() {
+    return decimalLowValue;
+  }
+
+  public void setDecimalLowValue(String decimalLowValue) {
+    this.decimalLowValue = decimalLowValue;
+  }
+
+  public String getDecimalHighValue() {
+    return decimalHighValue;
+  }
+
+  public void setDecimalHighValue(String decimalHighValue) {
+    this.decimalHighValue = decimalHighValue;
+  }
 }
diff --git a/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MTableColumnStatistics.java b/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MTableColumnStatistics.java
index c7ac9b9..85f6427 100644
--- a/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MTableColumnStatistics.java
+++ b/src/metastore/src/model/org/apache/hadoop/hive/metastore/model/MTableColumnStatistics.java
@@ -42,6 +42,8 @@
   private long longHighValue;
   private double doubleLowValue;
   private double doubleHighValue;
+  private String decimalLowValue;
+  private String decimalHighValue;
   private long numNulls;
   private long numDVs;
   private double avgColLen;
@@ -168,6 +170,14 @@ public void setDoubleStats(long numNulls, long numNDVs, double lowValue, double 
     this.doubleHighValue = highValue;
   }
 
+  public void setDecimalStats(
+      long numNulls, long numNDVs, String lowValue, String highValue) {
+    this.numNulls = numNulls;
+    this.numDVs = numNDVs;
+    this.decimalLowValue = lowValue;
+    this.decimalHighValue = highValue;
+  }
+
   public void setStringStats(long numNulls, long numNDVs, long maxColLen, double avgColLen) {
     this.numNulls = numNulls;
     this.numDVs = numNDVs;
@@ -212,4 +222,21 @@ public double getDoubleHighValue() {
   public void setDoubleHighValue(double doubleHighValue) {
     this.doubleHighValue = doubleHighValue;
   }
+
+
+  public String getDecimalLowValue() {
+    return decimalLowValue;
+  }
+
+  public void setDecimalLowValue(String decimalLowValue) {
+    this.decimalLowValue = decimalLowValue;
+  }
+
+  public String getDecimalHighValue() {
+    return decimalHighValue;
+  }
+
+  public void setDecimalHighValue(String decimalHighValue) {
+    this.decimalHighValue = decimalHighValue;
+  }
 }
diff --git a/src/metastore/src/model/package.jdo b/src/metastore/src/model/package.jdo
index 49f2aac..2ec430e 100644
--- a/src/metastore/src/model/package.jdo
+++ b/src/metastore/src/model/package.jdo
@@ -819,6 +819,12 @@
       <field name="doubleHighValue">
         <column name="DOUBLE_HIGH_VALUE" jdbc-type="DOUBLE" allows-null="true"/>
       </field>
+      <field name="decimalLowValue">
+        <column name="BIG_DECIMAL_LOW_VALUE"  jdbc-type="VARCHAR" allows-null="true"/>
+      </field>
+      <field name="decimalHighValue">
+        <column name="BIG_DECIMAL_HIGH_VALUE" jdbc-type="VARCHAR" allows-null="true"/>
+      </field>
       <field name="numNulls">
         <column name="NUM_NULLS" jdbc-type="BIGINT" allows-null="false"/>
       </field>
@@ -877,6 +883,12 @@
       <field name="doubleHighValue">
         <column name="DOUBLE_HIGH_VALUE" jdbc-type="DOUBLE" allows-null="true"/>
       </field>
+      <field name="decimalLowValue">
+        <column name="BIG_DECIMAL_LOW_VALUE"  jdbc-type="VARCHAR" allows-null="true"/>
+      </field>
+      <field name="decimalHighValue">
+        <column name="BIG_DECIMAL_HIGH_VALUE" jdbc-type="VARCHAR" allows-null="true"/>
+      </field>
       <field name="numNulls">
         <column name="NUM_NULLS" jdbc-type="BIGINT" allows-null="false"/>
       </field>
diff --git a/src/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnStatsTask.java b/src/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnStatsTask.java
index 99b062f..3dc02f0 100644
--- a/src/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnStatsTask.java
+++ b/src/ql/src/java/org/apache/hadoop/hive/ql/exec/ColumnStatsTask.java
@@ -20,11 +20,15 @@
 
 import java.io.IOException;
 import java.io.Serializable;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.common.type.HiveDecimal;
 import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hadoop.hive.metastore.api.BinaryColumnStatsData;
 import org.apache.hadoop.hive.metastore.api.BooleanColumnStatsData;
@@ -32,6 +36,8 @@
 import org.apache.hadoop.hive.metastore.api.ColumnStatisticsData;
 import org.apache.hadoop.hive.metastore.api.ColumnStatisticsDesc;
 import org.apache.hadoop.hive.metastore.api.ColumnStatisticsObj;
+import org.apache.hadoop.hive.metastore.api.Decimal;
+import org.apache.hadoop.hive.metastore.api.DecimalColumnStatsData;
 import org.apache.hadoop.hive.metastore.api.DoubleColumnStatsData;
 import org.apache.hadoop.hive.metastore.api.LongColumnStatsData;
 import org.apache.hadoop.hive.metastore.api.StringColumnStatsData;
@@ -48,6 +54,7 @@
 import org.apache.hadoop.hive.serde2.objectinspector.StructField;
 import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.DoubleObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.HiveDecimalObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.LongObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.primitive.StringObjectInspector;
 import org.apache.hadoop.mapred.JobConf;
@@ -110,6 +117,27 @@ private void unpackDoubleStats(ObjectInspector oi, Object o, String fName,
     }
   }
 
+  private void unpackDecimalStats(ObjectInspector oi, Object o, String fName,
+      ColumnStatisticsObj statsObj) {
+    if (fName.equals("countnulls")) {
+      long v = ((LongObjectInspector) oi).get(o);
+      statsObj.getStatsData().getDecimalStats().setNumNulls(v);
+    } else if (fName.equals("numdistinctvalues")) {
+      long v = ((LongObjectInspector) oi).get(o);
+      statsObj.getStatsData().getDecimalStats().setNumDVs(v);
+    } else if (fName.equals("max")) {
+      HiveDecimal d = ((HiveDecimalObjectInspector) oi).getPrimitiveJavaObject(o);
+      statsObj.getStatsData().getDecimalStats().setHighValue(convertToThriftDecimal(d));
+    } else if (fName.equals("min")) {
+      HiveDecimal d = ((HiveDecimalObjectInspector) oi).getPrimitiveJavaObject(o);
+      statsObj.getStatsData().getDecimalStats().setLowValue(convertToThriftDecimal(d));
+    }
+  }
+
+  private Decimal convertToThriftDecimal(HiveDecimal d) {
+    return new Decimal(ByteBuffer.wrap(d.unscaledValue().toByteArray()), (short)d.scale());
+  }
+
   private void unpackLongStats(ObjectInspector oi, Object o, String fName,
       ColumnStatisticsObj statsObj) {
     if (fName.equals("countnulls")) {
@@ -186,6 +214,10 @@ private void unpackPrimitiveObject (ObjectInspector oi, Object o, String fieldNa
         BinaryColumnStatsData binaryStats = new BinaryColumnStatsData();
         statsData.setBinaryStats(binaryStats);
         statsObj.setStatsData(statsData);
+      } else if (s.equalsIgnoreCase("decimal")) {
+        DecimalColumnStatsData decimalStats = new DecimalColumnStatsData();
+        statsData.setDecimalStats(decimalStats);
+        statsObj.setStatsData(statsData);
       }
     } else {
       // invoke the right unpack method depending on data type of the column
@@ -199,6 +231,8 @@ private void unpackPrimitiveObject (ObjectInspector oi, Object o, String fieldNa
         unpackStringStats(oi, o, fieldName, statsObj);
       } else if (statsObj.getStatsData().isSetBinaryStats()) {
         unpackBinaryStats(oi, o, fieldName, statsObj);
+      } else if (statsObj.getStatsData().isSetDecimalStats()) {
+        unpackDecimalStats(oi, o, fieldName, statsObj);
       }
     }
   }
diff --git a/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/DecimalNumDistinctValueEstimator.java b/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/DecimalNumDistinctValueEstimator.java
new file mode 100644
index 0000000..a05906e
--- /dev/null
+++ b/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/DecimalNumDistinctValueEstimator.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hive.ql.udf.generic;
+
+import org.apache.hadoop.hive.common.type.HiveDecimal;
+
+public class DecimalNumDistinctValueEstimator extends NumDistinctValueEstimator {
+
+  public DecimalNumDistinctValueEstimator(int numBitVectors) {
+    super(numBitVectors);
+  }
+
+  public DecimalNumDistinctValueEstimator(String s, int numBitVectors) {
+    super(s, numBitVectors);
+  }
+
+  public void addToEstimator(HiveDecimal decimal) {
+    int v = decimal.hashCode();
+    super.addToEstimator(v);
+  }
+
+  public void addToEstimatorPCSA(HiveDecimal decimal) {
+    int v = decimal.hashCode();
+    super.addToEstimatorPCSA(v);
+  }
+}
diff --git a/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFComputeStats.java b/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFComputeStats.java
index 7348478..3b063eb 100644
--- a/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFComputeStats.java
+++ b/src/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFComputeStats.java
@@ -17,28 +17,26 @@
  */
 package org.apache.hadoop.hive.ql.udf.generic;
 
+import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.hive.common.type.HiveDecimal;
 import org.apache.hadoop.hive.ql.exec.Description;
 import org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;
 import org.apache.hadoop.hive.ql.metadata.HiveException;
 import org.apache.hadoop.hive.ql.parse.SemanticException;
 import org.apache.hadoop.hive.ql.util.JavaDataModel;
 import org.apache.hadoop.hive.serde2.io.DoubleWritable;
+import org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;
 import org.apache.hadoop.hive.serde2.objectinspector.StructField;
 import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorUtils;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableDoubleObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableIntObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableLongObjectInspector;
-import org.apache.hadoop.hive.serde2.objectinspector.primitive.WritableStringObjectInspector;
+import org.apache.hadoop.hive.serde2.objectinspector.primitive.*;
 import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;
 import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;
 import org.apache.hadoop.io.BytesWritable;
@@ -88,9 +86,11 @@ public GenericUDAFEvaluator getEvaluator(TypeInfo[] parameters)
       return new GenericUDAFStringStatsEvaluator();
     case BINARY:
       return new GenericUDAFBinaryStatsEvaluator();
+    case DECIMAL:
+      return new GenericUDAFDecimalStatsEvaluator();
     default:
       throw new UDFArgumentTypeException(0,
-          "Only integer/long/timestamp/float/double/string/binary/boolean type argument " +
+          "Only integer/long/timestamp/float/double/string/binary/boolean/decimal type argument " +
           "is accepted but "
           + parameters[0].getTypeName() + " is passed.");
     }
@@ -1474,4 +1474,305 @@ public Object terminate(AggregationBuffer agg) throws HiveException {
       return result;
     }
   }
+
+  public static class GenericUDAFDecimalStatsEvaluator extends GenericUDAFEvaluator {
+
+    /*
+     * Object Inspector corresponding to the input parameter.
+     */
+    private transient PrimitiveObjectInspector inputOI;
+    private transient PrimitiveObjectInspector numVectorsOI;
+    private final static int MAX_BIT_VECTORS = 1024;
+
+    /* Partial aggregation result returned by TerminatePartial. Partial result is a struct
+     * containing a long field named "count".
+     */
+    private transient Object[] partialResult;
+
+    /* Object Inspectors corresponding to the struct returned by TerminatePartial and the long
+     * field within the struct - "count"
+     */
+    private transient StructObjectInspector soi;
+
+    private transient StructField minField;
+    private transient WritableHiveDecimalObjectInspector minFieldOI;
+
+    private transient StructField maxField;
+    private transient WritableHiveDecimalObjectInspector maxFieldOI;
+
+    private transient StructField countNullsField;
+    private transient WritableLongObjectInspector countNullsFieldOI;
+
+    private transient StructField ndvField;
+    private transient WritableStringObjectInspector ndvFieldOI;
+
+    private transient StructField numBitVectorsField;
+    private transient WritableIntObjectInspector numBitVectorsFieldOI;
+
+    /* Output of final result of the aggregation
+     */
+    private transient Object[] result;
+
+    private boolean warned = false;
+
+    @Override
+    public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException {
+      super.init(m, parameters);
+
+      // initialize input
+      if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {
+        inputOI = (PrimitiveObjectInspector) parameters[0];
+        numVectorsOI = (PrimitiveObjectInspector) parameters[1];
+      } else {
+        soi = (StructObjectInspector) parameters[0];
+
+        minField = soi.getStructFieldRef("Min");
+        minFieldOI = (WritableHiveDecimalObjectInspector) minField.getFieldObjectInspector();
+
+        maxField = soi.getStructFieldRef("Max");
+        maxFieldOI = (WritableHiveDecimalObjectInspector) maxField.getFieldObjectInspector();
+
+        countNullsField = soi.getStructFieldRef("CountNulls");
+        countNullsFieldOI = (WritableLongObjectInspector) countNullsField.getFieldObjectInspector();
+
+        ndvField = soi.getStructFieldRef("BitVector");
+        ndvFieldOI = (WritableStringObjectInspector) ndvField.getFieldObjectInspector();
+
+        numBitVectorsField = soi.getStructFieldRef("NumBitVectors");
+        numBitVectorsFieldOI = (WritableIntObjectInspector)
+            numBitVectorsField.getFieldObjectInspector();
+      }
+
+      // initialize output
+      if (mode == Mode.PARTIAL1 || mode == Mode.PARTIAL2) {
+        List<ObjectInspector> foi = new ArrayList<ObjectInspector>();
+        foi.add(PrimitiveObjectInspectorFactory.writableStringObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableHiveDecimalObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableHiveDecimalObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableLongObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableStringObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableIntObjectInspector);
+
+        List<String> fname = new ArrayList<String>();
+        fname.add("ColumnType");
+        fname.add("Min");
+        fname.add("Max");
+        fname.add("CountNulls");
+        fname.add("BitVector");
+        fname.add("NumBitVectors");
+
+        partialResult = new Object[6];
+        partialResult[0] = new Text();
+        partialResult[1] = new HiveDecimalWritable(HiveDecimal.create(0));
+        partialResult[2] = new HiveDecimalWritable(HiveDecimal.create(0));
+        partialResult[3] = new LongWritable(0);
+        partialResult[4] = new Text();
+        partialResult[5] = new IntWritable(0);
+
+        return ObjectInspectorFactory.getStandardStructObjectInspector(fname,
+            foi);
+      } else {
+        List<ObjectInspector> foi = new ArrayList<ObjectInspector>();
+        foi.add(PrimitiveObjectInspectorFactory.writableStringObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableHiveDecimalObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableHiveDecimalObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableLongObjectInspector);
+        foi.add(PrimitiveObjectInspectorFactory.writableLongObjectInspector);
+
+        List<String> fname = new ArrayList<String>();
+        fname.add("ColumnType");
+        fname.add("Min");
+        fname.add("Max");
+        fname.add("CountNulls");
+        fname.add("NumDistinctValues");
+
+        result = new Object[5];
+        result[0] = new Text();
+        result[1] = new HiveDecimalWritable(HiveDecimal.create(0));
+        result[2] = new HiveDecimalWritable(HiveDecimal.create(0));
+        result[3] = new LongWritable(0);
+        result[4] = new LongWritable(0);
+
+        return ObjectInspectorFactory.getStandardStructObjectInspector(fname,
+            foi);
+      }
+    }
+
+    @AggregationType(estimable = true)
+    public static class DecimalStatsAgg extends AbstractAggregationBuffer {
+      public String columnType;
+      public HiveDecimal min;                            /* Minimum value seen so far */
+      public HiveDecimal max;                            /* Maximum value seen so far */
+      public long countNulls;      /* Count of number of null values seen so far */
+      public DecimalNumDistinctValueEstimator numDV;  /* Distinct value estimator */
+      public boolean firstItem;                     /* First item in the aggBuf? */
+      public int numBitVectors;
+      @Override
+      public int estimate() {
+        JavaDataModel model = JavaDataModel.get();
+        return model.primitive1() * 2 + model.primitive2() + model.lengthOfDecimal() * 2 +
+            model.lengthFor(columnType) + model.lengthFor(numDV);
+      }
+    };
+
+    @Override
+    public AggregationBuffer getNewAggregationBuffer() throws HiveException {
+      DecimalStatsAgg result = new DecimalStatsAgg();
+      reset(result);
+      return result;
+    }
+
+    public void initNDVEstimator(DecimalStatsAgg aggBuffer, int numBitVectors) {
+      aggBuffer.numDV = new DecimalNumDistinctValueEstimator(numBitVectors);
+      aggBuffer.numDV.reset();
+    }
+
+    @Override
+    public void reset(AggregationBuffer agg) throws HiveException {
+      DecimalStatsAgg myagg = (DecimalStatsAgg) agg;
+      myagg.columnType = new String("Decimal");
+      myagg.min = HiveDecimal.create(0);
+      myagg.max = HiveDecimal.create(0);
+      myagg.countNulls = 0;
+      myagg.firstItem = true;
+    }
+
+    @Override
+    public void iterate(AggregationBuffer agg, Object[] parameters) throws HiveException {
+      Object p = parameters[0];
+      DecimalStatsAgg myagg = (DecimalStatsAgg) agg;
+      boolean emptyTable = false;
+
+      if (parameters[1] == null) {
+        emptyTable = true;
+      }
+
+      if (myagg.firstItem) {
+        int numVectors = 0;
+        if (!emptyTable) {
+          numVectors = PrimitiveObjectInspectorUtils.getInt(parameters[1], numVectorsOI);
+        }
+
+        if (numVectors > MAX_BIT_VECTORS) {
+          throw new HiveException("The maximum allowed value for number of bit vectors " +
+              " is " + MAX_BIT_VECTORS + ", but was passed " + numVectors + " bit vectors");
+        }
+
+        initNDVEstimator(myagg, numVectors);
+        myagg.firstItem = false;
+        myagg.numBitVectors = numVectors;
+      }
+
+      if (!emptyTable) {
+
+        //Update null counter if a null value is seen
+        if (p == null) {
+          myagg.countNulls++;
+        }
+        else {
+          try {
+
+            HiveDecimal v = PrimitiveObjectInspectorUtils.getHiveDecimal(p, inputOI);
+
+            //Update min counter if new value is less than min seen so far
+            if (v.compareTo(myagg.min) < 0) {
+              myagg.min = v;
+            }
+
+            //Update max counter if new value is greater than max seen so far
+            if (v.compareTo(myagg.max) > 0) {
+              myagg.max = v;
+            }
+
+            // Add value to NumDistinctValue Estimator
+            myagg.numDV.addToEstimator(v);
+
+          } catch (NumberFormatException e) {
+            if (!warned) {
+              warned = true;
+              LOG.warn(getClass().getSimpleName() + " "
+                  + StringUtils.stringifyException(e));
+              LOG.warn(getClass().getSimpleName()
+                  + " ignoring similar exceptions.");
+            }
+          }
+        }
+      }
+    }
+
+    @Override
+    public Object terminatePartial(AggregationBuffer agg) throws HiveException {
+      DecimalStatsAgg myagg = (DecimalStatsAgg) agg;
+
+      // Serialize numDistinctValue Estimator
+      Text t = myagg.numDV.serialize();
+
+      // Serialize the rest of the values in the AggBuffer
+      ((Text) partialResult[0]).set(myagg.columnType);
+      ((HiveDecimalWritable) partialResult[1]).set(myagg.min);
+      ((HiveDecimalWritable) partialResult[2]).set(myagg.max);
+      ((LongWritable) partialResult[3]).set(myagg.countNulls);
+      ((Text) partialResult[4]).set(t);
+      ((IntWritable) partialResult[5]).set(myagg.numBitVectors);
+
+      return partialResult;
+    }
+
+    @Override
+    public void merge(AggregationBuffer agg, Object partial) throws HiveException {
+      if (partial != null) {
+        DecimalStatsAgg myagg = (DecimalStatsAgg) agg;
+
+        if (myagg.firstItem) {
+          Object partialValue = soi.getStructFieldData(partial, numBitVectorsField);
+          int numVectors = numBitVectorsFieldOI.get(partialValue);
+          initNDVEstimator(myagg, numVectors);
+          myagg.firstItem = false;
+          myagg.numBitVectors = numVectors;
+        }
+
+        // Update min if min is lesser than the smallest value seen so far
+        Object partialValue = soi.getStructFieldData(partial, minField);
+        if (myagg.min.compareTo(minFieldOI.getPrimitiveJavaObject(partialValue)) > 0) {
+          myagg.min = minFieldOI.getPrimitiveJavaObject(partialValue);
+        }
+
+        // Update max if max is greater than the largest value seen so far
+        partialValue = soi.getStructFieldData(partial, maxField);
+        if (myagg.max.compareTo(maxFieldOI.getPrimitiveJavaObject(partialValue)) < 0) {
+          myagg.max = maxFieldOI.getPrimitiveJavaObject(partialValue);
+        }
+
+        // Update the null counter
+        partialValue = soi.getStructFieldData(partial, countNullsField);
+        myagg.countNulls += countNullsFieldOI.get(partialValue);
+
+        // Merge numDistinctValue Estimators
+        partialValue = soi.getStructFieldData(partial, ndvField);
+        String v = ndvFieldOI.getPrimitiveJavaObject(partialValue);
+
+        NumDistinctValueEstimator o = new NumDistinctValueEstimator(v, myagg.numBitVectors);
+        myagg.numDV.mergeEstimators(o);
+      }
+    }
+
+    @Override
+    public Object terminate(AggregationBuffer agg) throws HiveException {
+      DecimalStatsAgg myagg = (DecimalStatsAgg) agg;
+      long numDV = 0;
+
+      if (myagg.numBitVectors != 0) {
+        numDV = myagg.numDV.estimateNumDistinctValues();
+      }
+
+      // Serialize the result struct
+      ((Text) result[0]).set(myagg.columnType);
+      ((HiveDecimalWritable) result[1]).set(myagg.min);
+      ((HiveDecimalWritable) result[2]).set(myagg.max);
+      ((LongWritable) result[3]).set(myagg.countNulls);
+      ((LongWritable) result[4]).set(numDV);
+
+      return result;
+    }
+  }
 }
diff --git a/src/ql/src/java/org/apache/hadoop/hive/ql/util/JavaDataModel.java b/src/ql/src/java/org/apache/hadoop/hive/ql/util/JavaDataModel.java
index e3eec02..3352a08 100644
--- a/src/ql/src/java/org/apache/hadoop/hive/ql/util/JavaDataModel.java
+++ b/src/ql/src/java/org/apache/hadoop/hive/ql/util/JavaDataModel.java
@@ -27,99 +27,137 @@
 public enum JavaDataModel {
 
   JAVA32 {
+    @Override
     public int object() {
       return JAVA32_OBJECT;
     }
 
+    @Override
     public int array() {
       return JAVA32_ARRAY;
     }
 
+    @Override
     public int ref() {
       return JAVA32_REF;
     }
 
+    @Override
     public int hashMap(int entry) {
       // base  = JAVA32_OBJECT + PRIMITIVES1 * 4 + JAVA32_FIELDREF * 3 + JAVA32_ARRAY;
       // entry = JAVA32_OBJECT + JAVA32_FIELDREF + PRIMITIVES1
       return 64 + 24 * entry;
     }
 
+    @Override
+    public int hashMapEntry() {
+      return 24;
+    }
+
+    @Override
     public int hashSet(int entry) {
       // hashMap += JAVA32_OBJECT
       return 80 + 24 * entry;
     }
 
+    @Override
     public int linkedHashMap(int entry) {
       // hashMap += JAVA32_FIELDREF + PRIMITIVES1
       // hashMap.entry += JAVA32_FIELDREF * 2
       return 72 + 32 * entry;
     }
 
+    @Override
     public int linkedList(int entry) {
       // base  = JAVA32_OBJECT + PRIMITIVES1 * 2 + JAVA32_FIELDREF;
       // entry = JAVA32_OBJECT + JAVA32_FIELDREF * 2
       return 28 + 24 * entry;
     }
 
+    @Override
     public int arrayList() {
       // JAVA32_OBJECT + PRIMITIVES1 * 2 + JAVA32_ARRAY;
       return 44;
     }
+
+    @Override
+    public int memoryAlign() {
+      return 8;
+    }
   }, JAVA64 {
+    @Override
     public int object() {
       return JAVA64_OBJECT;
     }
 
+    @Override
     public int array() {
       return JAVA64_ARRAY;
     }
 
+    @Override
     public int ref() {
       return JAVA64_REF;
     }
 
+    @Override
     public int hashMap(int entry) {
       // base  = JAVA64_OBJECT + PRIMITIVES1 * 4 + JAVA64_FIELDREF * 3 + JAVA64_ARRAY;
       // entry = JAVA64_OBJECT + JAVA64_FIELDREF + PRIMITIVES1
       return 112 + 44 * entry;
     }
 
+    @Override
+    public int hashMapEntry() {
+      return 44;
+    }
+
+    @Override
     public int hashSet(int entry) {
       // hashMap += JAVA64_OBJECT
       return 144 + 44 * entry;
     }
 
+    @Override
     public int linkedHashMap(int entry) {
       // hashMap += JAVA64_FIELDREF + PRIMITIVES1
       // hashMap.entry += JAVA64_FIELDREF * 2
       return 128 + 60 * entry;
     }
 
+    @Override
     public int linkedList(int entry) {
       // base  = JAVA64_OBJECT + PRIMITIVES1 * 2 + JAVA64_FIELDREF;
       // entry = JAVA64_OBJECT + JAVA64_FIELDREF * 2
       return 48 + 48 * entry;
     }
 
+    @Override
     public int arrayList() {
       // JAVA64_OBJECT + PRIMITIVES1 * 2 + JAVA64_ARRAY;
       return 80;
     }
+
+    @Override
+    public int memoryAlign() {
+      return 8;
+    }
   };
 
   public abstract int object();
   public abstract int array();
   public abstract int ref();
   public abstract int hashMap(int entry);
+  public abstract int hashMapEntry();
   public abstract int hashSet(int entry);
   public abstract int linkedHashMap(int entry);
   public abstract int linkedList(int entry);
   public abstract int arrayList();
+  public abstract int memoryAlign();
 
   // ascii string
   public int lengthFor(String string) {
-    return object() + primitive1() * 3 + array() + string.length();
+    return lengthForStringOfLength(string.length());
   }
 
   public int lengthFor(NumericHistogram histogram) {
@@ -161,6 +199,10 @@ public int primitive2() {
     return PRIMITIVES2;
   }
 
+  public static int alignUp(int value, int align) {
+    return (value + align - 1) & ~(align - 1);
+  }
+
   public static final int JAVA32_META = 12;
   public static final int JAVA32_ARRAY_META = 16;
   public static final int JAVA32_REF = 4;
@@ -176,6 +218,8 @@ public int primitive2() {
   public static final int PRIMITIVES1 = 4;      // void, boolean, byte, short, int, float
   public static final int PRIMITIVES2 = 8;      // long, double
 
+  public static final int PRIMITIVE_BYTE = 1;    // byte
+
   private static JavaDataModel current;
 
   public static JavaDataModel get() {
@@ -200,4 +244,65 @@ public static int round(int size) {
     }
     return ((size + 8) >> 3) << 3;
   }
+
+  private int lengthForPrimitiveArrayOfSize(int primitiveSize, int length) {
+    return alignUp(array() + primitiveSize*length, memoryAlign());
+  }
+
+  public int lengthForByteArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(PRIMITIVE_BYTE, length);
+  }
+  public int lengthForObjectArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(ref(), length);
+  }
+  public int lengthForLongArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(primitive2(), length);
+  }
+  public int lengthForDoubleArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(primitive2(), length);
+  }
+  public int lengthForIntArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(primitive1(), length);
+  }
+  public int lengthForBooleanArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(PRIMITIVE_BYTE, length);
+  }
+  public int lengthForTimestampArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(lengthOfTimestamp(), length);
+  }
+  public int lengthForDateArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(lengthOfDate(), length);
+  }
+  public int lengthForDecimalArrayOfSize(int length) {
+    return lengthForPrimitiveArrayOfSize(lengthOfDecimal(), length);
+  }
+
+  public int lengthOfDecimal() {
+    // object overhead + 8 bytes for intCompact + 4 bytes for precision
+    // + 4 bytes for scale + size of BigInteger
+    return object() + 2 * primitive2() + lengthOfBigInteger();
+  }
+
+  private int lengthOfBigInteger() {
+    // object overhead + 4 bytes for bitCount + 4 bytes for bitLength
+    // + 4 bytes for firstNonzeroByteNum + 4 bytes for firstNonzeroIntNum +
+    // + 4 bytes for lowestSetBit + 5 bytes for size of magnitude (since max precision
+    // is only 38 for HiveDecimal) + 7 bytes of padding (since java memory allocations
+    // are 8 byte aligned)
+    return object() + 4 * primitive2();
+  }
+
+  public int lengthOfTimestamp() {
+    // object overhead + 4 bytes for int (nanos) + 4 bytes of padding
+    return object() + primitive2();
+  }
+
+  public int lengthOfDate() {
+    // object overhead + 8 bytes for long (fastTime) + 16 bytes for cdate
+    return object() + 3 * primitive2();
+  }
+
+  public int lengthForStringOfLength(int strLen) {
+    return object() + primitive1() * 3 + array() + strLen;
+  }
 }
diff --git a/src/ql/src/test/queries/clientpositive/compute_stats_decimal.q b/src/ql/src/test/queries/clientpositive/compute_stats_decimal.q
new file mode 100644
index 0000000..77ec066
--- /dev/null
+++ b/src/ql/src/test/queries/clientpositive/compute_stats_decimal.q
@@ -0,0 +1,11 @@
+set hive.stats.autogather=true;
+
+create table tab_decimal(a decimal(10,3));
+
+-- insert some data
+LOAD DATA LOCAL INPATH "../../data/files/decimal.txt" INTO TABLE tab_decimal;
+
+select count(*) from tab_decimal;
+
+-- compute statistical summary of data
+select compute_stats(a, 18) from tab_decimal;
diff --git a/src/ql/src/test/results/clientpositive/compute_stats_decimal.q.out b/src/ql/src/test/results/clientpositive/compute_stats_decimal.q.out
new file mode 100644
index 0000000..86b24ab
--- /dev/null
+++ b/src/ql/src/test/results/clientpositive/compute_stats_decimal.q.out
@@ -0,0 +1,33 @@
+PREHOOK: query: create table tab_decimal(a decimal(10,3))
+PREHOOK: type: CREATETABLE
+POSTHOOK: query: create table tab_decimal(a decimal(10,3))
+POSTHOOK: type: CREATETABLE
+POSTHOOK: Output: default@tab_decimal
+PREHOOK: query: -- insert some data
+LOAD DATA LOCAL INPATH "../../data/files/decimal.txt" INTO TABLE tab_decimal
+PREHOOK: type: LOAD
+PREHOOK: Output: default@tab_decimal
+POSTHOOK: query: -- insert some data
+LOAD DATA LOCAL INPATH "../../data/files/decimal.txt" INTO TABLE tab_decimal
+POSTHOOK: type: LOAD
+POSTHOOK: Output: default@tab_decimal
+PREHOOK: query: select count(*) from tab_decimal
+PREHOOK: type: QUERY
+PREHOOK: Input: default@tab_decimal
+#### A masked pattern was here ####
+POSTHOOK: query: select count(*) from tab_decimal
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@tab_decimal
+#### A masked pattern was here ####
+18
+PREHOOK: query: -- compute statistical summary of data
+select compute_stats(a, 18) from tab_decimal
+PREHOOK: type: QUERY
+PREHOOK: Input: default@tab_decimal
+#### A masked pattern was here ####
+POSTHOOK: query: -- compute statistical summary of data
+select compute_stats(a, 18) from tab_decimal
+POSTHOOK: type: QUERY
+POSTHOOK: Input: default@tab_decimal
+#### A masked pattern was here ####
+{"columntype":"Decimal","min":-87.2,"max":435.331,"countnulls":2,"numdistinctvalues":13}
diff --git a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde/test/ThriftTestObj.java b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde/test/ThriftTestObj.java
index dda3c5f..1b708dd 100644
--- a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde/test/ThriftTestObj.java
+++ b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde/test/ThriftTestObj.java
@@ -528,7 +528,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, ThriftTestObj struc
                 struct.field3 = new ArrayList<InnerStruct>(_list0.size);
                 for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                 {
-                  InnerStruct _elem2; // optional
+                  InnerStruct _elem2; // required
                   _elem2 = new InnerStruct();
                   _elem2.read(iprot);
                   struct.field3.add(_elem2);
@@ -636,7 +636,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, ThriftTestObj struct
           struct.field3 = new ArrayList<InnerStruct>(_list5.size);
           for (int _i6 = 0; _i6 < _list5.size; ++_i6)
           {
-            InnerStruct _elem7; // optional
+            InnerStruct _elem7; // required
             _elem7 = new InnerStruct();
             _elem7.read(iprot);
             struct.field3.add(_elem7);
diff --git a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/Complex.java b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/Complex.java
index aa404bf..e36a792 100644
--- a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/Complex.java
+++ b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/Complex.java
@@ -836,7 +836,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, Complex struct) thr
                 struct.lint = new ArrayList<Integer>(_list0.size);
                 for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                 {
-                  int _elem2; // optional
+                  int _elem2; // required
                   _elem2 = iprot.readI32();
                   struct.lint.add(_elem2);
                 }
@@ -854,7 +854,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, Complex struct) thr
                 struct.lString = new ArrayList<String>(_list3.size);
                 for (int _i4 = 0; _i4 < _list3.size; ++_i4)
                 {
-                  String _elem5; // optional
+                  String _elem5; // required
                   _elem5 = iprot.readString();
                   struct.lString.add(_elem5);
                 }
@@ -872,7 +872,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, Complex struct) thr
                 struct.lintString = new ArrayList<IntString>(_list6.size);
                 for (int _i7 = 0; _i7 < _list6.size; ++_i7)
                 {
-                  IntString _elem8; // optional
+                  IntString _elem8; // required
                   _elem8 = new IntString();
                   _elem8.read(iprot);
                   struct.lintString.add(_elem8);
@@ -1074,7 +1074,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, Complex struct) thro
           struct.lint = new ArrayList<Integer>(_list21.size);
           for (int _i22 = 0; _i22 < _list21.size; ++_i22)
           {
-            int _elem23; // optional
+            int _elem23; // required
             _elem23 = iprot.readI32();
             struct.lint.add(_elem23);
           }
@@ -1087,7 +1087,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, Complex struct) thro
           struct.lString = new ArrayList<String>(_list24.size);
           for (int _i25 = 0; _i25 < _list24.size; ++_i25)
           {
-            String _elem26; // optional
+            String _elem26; // required
             _elem26 = iprot.readString();
             struct.lString.add(_elem26);
           }
@@ -1100,7 +1100,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, Complex struct) thro
           struct.lintString = new ArrayList<IntString>(_list27.size);
           for (int _i28 = 0; _i28 < _list27.size; ++_i28)
           {
-            IntString _elem29; // optional
+            IntString _elem29; // required
             _elem29 = new IntString();
             _elem29.read(iprot);
             struct.lintString.add(_elem29);
diff --git a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/MegaStruct.java b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/MegaStruct.java
index fba49e4..386fef9 100644
--- a/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/MegaStruct.java
+++ b/src/serde/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/serde2/thrift/test/MegaStruct.java
@@ -2280,7 +2280,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                     _val19 = new ArrayList<String>(_list20.size);
                     for (int _i21 = 0; _i21 < _list20.size; ++_i21)
                     {
-                      String _elem22; // optional
+                      String _elem22; // required
                       _elem22 = iprot.readString();
                       _val19.add(_elem22);
                     }
@@ -2310,7 +2310,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                     _val26 = new ArrayList<MiniStruct>(_list27.size);
                     for (int _i28 = 0; _i28 < _list27.size; ++_i28)
                     {
-                      MiniStruct _elem29; // optional
+                      MiniStruct _elem29; // required
                       _elem29 = new MiniStruct();
                       _elem29.read(iprot);
                       _val26.add(_elem29);
@@ -2333,7 +2333,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_stringlist = new ArrayList<String>(_list30.size);
                 for (int _i31 = 0; _i31 < _list30.size; ++_i31)
                 {
-                  String _elem32; // optional
+                  String _elem32; // required
                   _elem32 = iprot.readString();
                   struct.my_stringlist.add(_elem32);
                 }
@@ -2351,7 +2351,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_structlist = new ArrayList<MiniStruct>(_list33.size);
                 for (int _i34 = 0; _i34 < _list33.size; ++_i34)
                 {
-                  MiniStruct _elem35; // optional
+                  MiniStruct _elem35; // required
                   _elem35 = new MiniStruct();
                   _elem35.read(iprot);
                   struct.my_structlist.add(_elem35);
@@ -2370,7 +2370,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_enumlist = new ArrayList<MyEnum>(_list36.size);
                 for (int _i37 = 0; _i37 < _list36.size; ++_i37)
                 {
-                  MyEnum _elem38; // optional
+                  MyEnum _elem38; // required
                   _elem38 = MyEnum.findByValue(iprot.readI32());
                   struct.my_enumlist.add(_elem38);
                 }
@@ -2388,7 +2388,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_stringset = new HashSet<String>(2*_set39.size);
                 for (int _i40 = 0; _i40 < _set39.size; ++_i40)
                 {
-                  String _elem41; // optional
+                  String _elem41; // required
                   _elem41 = iprot.readString();
                   struct.my_stringset.add(_elem41);
                 }
@@ -2406,7 +2406,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_enumset = new HashSet<MyEnum>(2*_set42.size);
                 for (int _i43 = 0; _i43 < _set42.size; ++_i43)
                 {
-                  MyEnum _elem44; // optional
+                  MyEnum _elem44; // required
                   _elem44 = MyEnum.findByValue(iprot.readI32());
                   struct.my_enumset.add(_elem44);
                 }
@@ -2424,7 +2424,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, MegaStruct struct) 
                 struct.my_structset = new HashSet<MiniStruct>(2*_set45.size);
                 for (int _i46 = 0; _i46 < _set45.size; ++_i46)
                 {
-                  MiniStruct _elem47; // optional
+                  MiniStruct _elem47; // required
                   _elem47 = new MiniStruct();
                   _elem47.read(iprot);
                   struct.my_structset.add(_elem47);
@@ -3023,7 +3023,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
               _val95 = new ArrayList<String>(_list96.size);
               for (int _i97 = 0; _i97 < _list96.size; ++_i97)
               {
-                String _elem98; // optional
+                String _elem98; // required
                 _elem98 = iprot.readString();
                 _val95.add(_elem98);
               }
@@ -3047,7 +3047,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
               _val102 = new ArrayList<MiniStruct>(_list103.size);
               for (int _i104 = 0; _i104 < _list103.size; ++_i104)
               {
-                MiniStruct _elem105; // optional
+                MiniStruct _elem105; // required
                 _elem105 = new MiniStruct();
                 _elem105.read(iprot);
                 _val102.add(_elem105);
@@ -3064,7 +3064,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_stringlist = new ArrayList<String>(_list106.size);
           for (int _i107 = 0; _i107 < _list106.size; ++_i107)
           {
-            String _elem108; // optional
+            String _elem108; // required
             _elem108 = iprot.readString();
             struct.my_stringlist.add(_elem108);
           }
@@ -3077,7 +3077,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_structlist = new ArrayList<MiniStruct>(_list109.size);
           for (int _i110 = 0; _i110 < _list109.size; ++_i110)
           {
-            MiniStruct _elem111; // optional
+            MiniStruct _elem111; // required
             _elem111 = new MiniStruct();
             _elem111.read(iprot);
             struct.my_structlist.add(_elem111);
@@ -3091,7 +3091,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_enumlist = new ArrayList<MyEnum>(_list112.size);
           for (int _i113 = 0; _i113 < _list112.size; ++_i113)
           {
-            MyEnum _elem114; // optional
+            MyEnum _elem114; // required
             _elem114 = MyEnum.findByValue(iprot.readI32());
             struct.my_enumlist.add(_elem114);
           }
@@ -3104,7 +3104,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_stringset = new HashSet<String>(2*_set115.size);
           for (int _i116 = 0; _i116 < _set115.size; ++_i116)
           {
-            String _elem117; // optional
+            String _elem117; // required
             _elem117 = iprot.readString();
             struct.my_stringset.add(_elem117);
           }
@@ -3117,7 +3117,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_enumset = new HashSet<MyEnum>(2*_set118.size);
           for (int _i119 = 0; _i119 < _set118.size; ++_i119)
           {
-            MyEnum _elem120; // optional
+            MyEnum _elem120; // required
             _elem120 = MyEnum.findByValue(iprot.readI32());
             struct.my_enumset.add(_elem120);
           }
@@ -3130,7 +3130,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, MegaStruct struct) t
           struct.my_structset = new HashSet<MiniStruct>(2*_set121.size);
           for (int _i122 = 0; _i122 < _set121.size; ++_i122)
           {
-            MiniStruct _elem123; // optional
+            MiniStruct _elem123; // required
             _elem123 = new MiniStruct();
             _elem123.read(iprot);
             struct.my_structset.add(_elem123);
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/service/ThriftHive.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/service/ThriftHive.java
index 1c44789..745e6cc 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/service/ThriftHive.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hadoop/hive/service/ThriftHive.java
@@ -3023,7 +3023,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, fetchN_result struc
                   struct.success = new ArrayList<String>(_list0.size);
                   for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                   {
-                    String _elem2; // optional
+                    String _elem2; // required
                     _elem2 = iprot.readString();
                     struct.success.add(_elem2);
                   }
@@ -3122,7 +3122,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, fetchN_result struct
             struct.success = new ArrayList<String>(_list5.size);
             for (int _i6 = 0; _i6 < _list5.size; ++_i6)
             {
-              String _elem7; // optional
+              String _elem7; // required
               _elem7 = iprot.readString();
               struct.success.add(_elem7);
             }
@@ -3785,7 +3785,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, fetchAll_result str
                   struct.success = new ArrayList<String>(_list8.size);
                   for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                   {
-                    String _elem10; // optional
+                    String _elem10; // required
                     _elem10 = iprot.readString();
                     struct.success.add(_elem10);
                   }
@@ -3884,7 +3884,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, fetchAll_result stru
             struct.success = new ArrayList<String>(_list13.size);
             for (int _i14 = 0; _i14 < _list13.size; ++_i14)
             {
-              String _elem15; // optional
+              String _elem15; // required
               _elem15 = iprot.readString();
               struct.success.add(_elem15);
             }
-- 
1.7.0.4

